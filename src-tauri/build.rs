use std::fs;
use std::path::Path;

fn main() {
    // ts-rs 출력 디렉토리 설정
    println!("cargo:rustc-env=TS_RS_EXPORT_DIR=../src/types/generated");

    tauri_build::build();

    // 빌드 후 TypeScript 타입들을 단일 index.ts 파일로 통합
    let generated_types_dir = Path::new("../src/types/generated");

    if generated_types_dir.exists() {
        generate_unified_types_index(generated_types_dir).unwrap_or_else(|e| {
            println!("cargo:warning=Failed to generate unified types index: {e}");
        });
    }
}

fn generate_unified_types_index(types_dir: &Path) -> std::io::Result<()> {
    let index_path = types_dir.join("index.ts");
    let mut exports = Vec::new();

    // .ts 파일들을 읽어서 export 구문 생성
    for entry in fs::read_dir(types_dir)? {
        let entry = entry?;
        let path = entry.path();

        if let Some(file_name) = path.file_name() {
            if let Some(file_name_str) = file_name.to_str() {
                if std::path::Path::new(file_name_str)
                    .extension()
                    .is_some_and(|ext| ext.eq_ignore_ascii_case("ts"))
                    && file_name_str != "index.ts"
                {
                    let type_name = file_name_str.trim_end_matches(".ts");
                    exports.push(format!(
                        "export type {{ {type_name} }} from './{type_name}';"
                    ));
                }
            }
        }
    }

    // 알파벳 순으로 정렬
    exports.sort();

    let index_content = format!(
        "// This file was auto-generated by build.rs. Do not edit manually.\n// All TypeScript types exported from Rust code\n\n{}\n",
        exports.join("\n")
    );

    fs::write(index_path, index_content)?;
    println!(
        "cargo:warning=Generated unified types index with {} exports",
        exports.len()
    );

    Ok(())
}
