//! StageActor: 개별 스테이지 작업 처리 Actor
//! 
//! Phase 3: Actor 구현 - 스테이지 레벨 작업 실행 및 관리
//! Modern Rust 2024 준수: 함수형 원칙, 명시적 의존성, 상태 최소화

#![warn(clippy::all, clippy::pedantic, clippy::nursery)]
#![deny(clippy::unwrap_used, clippy::expect_used, clippy::panic)]

use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use tokio::time::timeout;
use tracing::{info, warn, error, debug};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::ne    /// 크롤링 엔진과 함께 단일 아이템 처리 (정적 메서드)
    /// 
    /// # Arguments
    /// * `stage_type` - 스테이지 타입
    /// * `item` - 처리할 아이템
    /// * `http_client` - HTTP 클라이언트
    /// * `data_extractor` - 데이터 추출기
    /// * `database_connection` - 데이터베이스 연결
    async fn process_item_with_engines(
        stage_type: StageType,
        item: StageItem,
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>,
        database_connection: &Option<Arc<DatabaseConnection>>,
    ) -> Result<StageItemResult, StageError> {
        let start_time = Instant::now();
        
        debug!("Processing item {} for stage {:?}", item.id, stage_type);
        
        // 스테이지 타입별 처리 로직
        let success = match stage_type {
            StageType::StatusCheck => {
                // ✅ 실제 상태 확인 로직
                Self::perform_status_check(&item, http_client).await
            }
            StageType::ListPageCrawling => {
                // ✅ 실제 리스트 페이지 크롤링 로직
                Self::perform_list_page_crawling(&item, http_client, data_extractor).await
            }
            StageType::ProductDetailCrawling => {
                // ✅ 실제 상품 상세 크롤링 로직
                Self::perform_product_detail_crawling(&item, http_client, data_extractor).await
            }
            StageType::DataValidation => {
                // ✅ 실제 데이터 검증 로직
                Self::perform_data_validation(&item).await
            }
            StageType::DataSaving => {
                // ✅ 실제 데이터베이스 저장 로직
                Self::perform_database_storage(&item, database_connection).await
            }
        };
        
        let duration = start_time.elapsed();
        
        match success {
            Ok(()) => Ok(StageItemResult {
                item_id: item.id,
                item_type: item.item_type,
                success: true,
                error: None,
                duration_ms: duration.as_millis() as u64,
                retry_count: 0,
            }),
            Err(error) => Ok(StageItemResult {
                item_id: item.id.clone(),
                item_type: item.item_type,
                success: false,
                error: Some(error.clone()),
                duration_ms: duration.as_millis() as u64,
                retry_count: 0,
            }),
        }
    }
    
    /// 단일 아이템 처리 (인스턴스 메서드)
    /// 
    /// # Arguments
    /// * `stage_type` - 스테이지 타입
    /// * `item` - 처리할 아이템
    async fn process_single_item(
        &self,
        stage_type: StageType,
        item: StageItem,
    ) -> Result<StageItemResult, StageError> {cture::actors::types::{StageItemResult, StageItemType};

use super::traits::{Actor, ActorHealth, ActorStatus, ActorType};
use super::types::{ActorCommand, StageType, StageItem, StageResult, ActorError};
use crate::new_architecture::channels::types::AppEvent;
use crate::new_architecture::context::{AppContext, EventEmitter};

// 실제 크롤링 엔진 import 추가
use crate::infrastructure::{HttpClient, MatterDataExtractor, DatabaseConnection};
use crate::domain::value_objects::ProductData;

/// StageActor: 개별 스테이지 작업의 실행 및 관리
/// 
/// 책임:
/// - 특정 스테이지 타입의 작업 실행
/// - 아이템별 처리 및 결과 수집
/// - 스테이지 레벨 이벤트 발행
/// - 타임아웃 및 재시도 로직 관리
#[derive(Debug)]
pub struct StageActor {
    /// Actor 고유 식별자
    actor_id: String,
    /// 배치 ID (OneShot 호환성)
    pub batch_id: String,
    /// 현재 처리 중인 스테이지 ID
    stage_id: Option<String>,
    /// 스테이지 타입
    stage_type: Option<StageType>,
    /// 스테이지 상태
    state: StageState,
    /// 스테이지 시작 시간
    start_time: Option<Instant>,
    /// 총 아이템 수
    total_items: u32,
    /// 처리 완료된 아이템 수
    completed_items: u32,
    /// 성공한 아이템 수
    success_count: u32,
    /// 실패한 아이템 수
    failure_count: u32,
    /// 스키핑된 아이템 수
    skipped_count: u32,
    /// 처리 결과들
    item_results: Vec<StageItemResult>,
    
    // ✅ 실제 크롤링 엔진 의존성 추가
    /// HTTP 클라이언트 (실제 웹 요청)
    http_client: Option<Arc<HttpClient>>,
    /// 데이터 추출기 (HTML 파싱)
    data_extractor: Option<Arc<MatterDataExtractor>>,
    /// 데이터베이스 연결 (데이터 저장)
    database_connection: Option<Arc<DatabaseConnection>>,
}

/// 스테이지 상태 열거형
#[derive(Debug, Clone, PartialEq)]
pub enum StageState {
    Idle,
    Starting,
    Processing,
    Completing,
    Completed,
    Failed { error: String },
    Timeout,
}

/// 스테이지 관련 에러 타입
#[derive(Debug, thiserror::Error)]
pub enum StageError {
    #[error("Stage initialization failed: {0}")]
    InitializationFailed(String),
    
    #[error("Stage already processing: {0}")]
    AlreadyProcessing(String),
    
    #[error("Stage not found: {0}")]
    StageNotFound(String),
    
    #[error("Invalid stage configuration: {0}")]
    InvalidConfiguration(String),
    
    #[error("Stage processing timeout: {timeout_secs}s")]
    ProcessingTimeout { timeout_secs: u64 },
    
    #[error("Item processing failed: {item_id} - {error}")]
    ItemProcessingFailed { item_id: String, error: String },
    
    #[error("Context communication error: {0}")]
    ContextError(String),
    
    #[error("Unsupported stage type: {0:?}")]
    UnsupportedStageType(StageType),
}

impl StageActor {
    /// 새로운 StageActor 인스턴스 생성
    /// 
    /// # Arguments
    /// * `actor_id` - Actor 고유 식별자
    /// 
    /// # Returns
    /// * `Self` - 새로운 StageActor 인스턴스
    pub fn new(actor_id: String) -> Self {
        let batch_id = Uuid::new_v4().to_string();
        Self {
            actor_id,
            batch_id,
            stage_id: None,
            stage_type: None,
            state: StageState::Idle,
            start_time: None,
            total_items: 0,
            completed_items: 0,
            success_count: 0,
            failure_count: 0,
            skipped_count: 0,
            item_results: Vec::new(),
            
            // 실제 크롤링 엔진 초기화 (None으로 시작, 나중에 설정)
            http_client: None,
            data_extractor: None,
            database_connection: None,
        }
    }
    
    /// OneShot Actor 시스템 호환성을 위한 생성자
    /// 
    /// # Arguments
    /// * `batch_id` - 배치 식별자
    /// * `config` - 시스템 설정
    /// * `total_pages` - 총 페이지 수 (선택적)
    /// * `products_on_last_page` - 마지막 페이지 제품 수 (선택적)
    /// 
    /// # Returns
    /// * `Self` - 새로운 StageActor 인스턴스
    pub fn new_with_oneshot(
        batch_id: String, 
        _config: Arc<crate::new_architecture::config::SystemConfig>,
        _total_pages: u32,
        _products_on_last_page: u32
    ) -> Self {
        let actor_id = Uuid::new_v4().to_string();
        Self {
            actor_id,
            batch_id,
            stage_id: None,
            stage_type: None,
            state: StageState::Idle,
            start_time: None,
            total_items: 0,
            completed_items: 0,
            success_count: 0,
            failure_count: 0,
            skipped_count: 0,
            item_results: Vec::new(),
            
            // 실제 크롤링 엔진 초기화 (None으로 시작, 나중에 설정)
            http_client: None,
            data_extractor: None,
            database_connection: None,
        }
    }
    
    /// 실제 크롤링 엔진 의존성 설정
    /// 
    /// # Arguments
    /// * `http_client` - HTTP 클라이언트
    /// * `data_extractor` - 데이터 추출기
    /// * `database_connection` - 데이터베이스 연결
    pub fn with_crawling_engines(
        mut self,
        http_client: Arc<HttpClient>,
        data_extractor: Arc<MatterDataExtractor>,
        database_connection: Arc<DatabaseConnection>,
    ) -> Self {
        self.http_client = Some(http_client);
        self.data_extractor = Some(data_extractor);
        self.database_connection = Some(database_connection);
        self
    }
    
    /// 크롤링 엔진 초기화 (기본 설정으로)
    pub async fn initialize_default_engines(&mut self) -> Result<(), StageError> {
        // HttpClient 초기화
        let http_client = HttpClient::create_from_global_config()
            .map_err(|e| StageError::InitializationFailed(format!("Failed to create HttpClient: {}", e)))?;
        
        // MatterDataExtractor 초기화  
        let data_extractor = Arc::new(MatterDataExtractor::new());
        
        // DatabaseConnection 초기화 (기본 데이터베이스 URL 사용)
        let database_url = std::env::var("DATABASE_URL")
            .unwrap_or_else(|_| "sqlite:./matter_certis.db".to_string());
        let database_connection = DatabaseConnection::new(&database_url).await
            .map_err(|e| StageError::InitializationFailed(format!("Failed to create DatabaseConnection: {}", e)))?;
        
        self.http_client = Some(Arc::new(http_client));
        self.data_extractor = Some(data_extractor);
        self.database_connection = Some(Arc::new(database_connection));
        
        Ok(())
    }
    
    /// 공개 스테이지 실행 메서드 (BatchActor에서 사용)
    /// 
    /// # Arguments
    /// * `stage_type` - 실행할 스테이지 타입
    /// * `items` - 처리할 아이템 리스트
    /// * `concurrency_limit` - 동시성 제한
    /// * `timeout_secs` - 타임아웃 (초)
    /// * `context` - Actor 컨텍스트
    pub async fn execute_stage(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        timeout_secs: u64,
        context: &AppContext,
    ) -> Result<StageResult, StageError> {
        self.handle_execute_stage(
            stage_type.clone(),
            items,
            concurrency_limit,
            timeout_secs,
            context,
        ).await?;
        
        Ok(StageResult {
            processed_items: self.completed_items,
            successful_items: self.success_count,
            failed_items: self.failure_count,
            duration_ms: self.start_time.map(|start| start.elapsed().as_millis() as u64).unwrap_or(0),
            details: self.item_results.clone(),
        })
    }
    
    /// 스테이지 실행 처리
    /// 
    /// # Arguments
    /// * `stage_type` - 실행할 스테이지 타입
    /// * `items` - 처리할 아이템 리스트
    /// * `concurrency_limit` - 동시성 제한
    /// * `timeout_secs` - 타임아웃 (초)
    /// * `context` - Actor 컨텍스트
    async fn handle_execute_stage(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        timeout_secs: u64,
        context: &AppContext,
    ) -> Result<(), StageError> {
        // 상태 검증
        if !matches!(self.state, StageState::Idle) {
            return Err(StageError::AlreadyProcessing(
                self.stage_id.clone().unwrap_or_else(|| "unknown".to_string())
            ));
        }
        
        let stage_id = Uuid::new_v4().to_string();
        
        info!("🎯 StageActor {} executing stage {:?} with {} items", 
              self.actor_id, stage_type, items.len());
        
        // 상태 초기화
        self.stage_id = Some(stage_id.clone());
        self.stage_type = Some(stage_type.clone());
        self.state = StageState::Starting;
        self.start_time = Some(Instant::now());
        self.total_items = items.len() as u32;
        self.completed_items = 0;
        self.success_count = 0;
        self.failure_count = 0;
        self.skipped_count = 0;
        self.item_results.clear();
        
        // 스테이지 시작 이벤트 발행
        let start_event = AppEvent::StageStarted {
            stage_type: stage_type.clone(),
            session_id: context.session_id.clone(),
            items_count: items.len() as u32,
            timestamp: Utc::now(),
        };
        
        context.emit_event(start_event).await
            .map_err(|e| StageError::ContextError(e.to_string()))?;
        
        // 상태를 Processing으로 전환
        self.state = StageState::Processing;
        
        // 타임아웃과 함께 스테이지 처리
        let processing_result = timeout(
            Duration::from_secs(timeout_secs),
            self.process_stage_items(stage_type.clone(), items, concurrency_limit, context)
        ).await;
        
        match processing_result {
            Ok(result) => {
                match result {
                    Ok(stage_result) => {
                        self.state = StageState::Completed;
                        
                        // 완료 이벤트 발행
                        let completion_event = AppEvent::StageCompleted {
                            stage_type: stage_type.clone(),
                            session_id: context.session_id.clone(),
                            result: stage_result,
                            timestamp: Utc::now(),
                        };
                        
                        context.emit_event(completion_event).await
                            .map_err(|e| StageError::ContextError(e.to_string()))?;
                        
                        info!("✅ Stage {:?} completed successfully: {}/{} items processed", 
                              stage_type, self.success_count, self.total_items);
                    }
                    Err(e) => {
                        let error_msg = e.to_string();
                        self.state = StageState::Failed { error: error_msg.clone() };
                        
                        // 실패 이벤트 발행
                        let failure_event = AppEvent::StageFailed {
                            stage_type: stage_type.clone(),
                            session_id: context.session_id.clone(),
                            error: error_msg,
                            timestamp: Utc::now(),
                        };
                        
                        context.emit_event(failure_event).await
                            .map_err(|e| StageError::ContextError(e.to_string()))?;
                        
                        return Err(e);
                    }
                }
            }
            Err(_) => {
                // 타임아웃 발생
                self.state = StageState::Timeout;
                
                let error = StageError::ProcessingTimeout { timeout_secs };
                
                // 타임아웃 이벤트 발행
                let timeout_event = AppEvent::StageFailed {
                    stage_type: stage_type.clone(),
                    session_id: context.session_id.clone(),
                    error: error.to_string(),
                    timestamp: Utc::now(),
                };
                
                context.emit_event(timeout_event).await
                    .map_err(|e| StageError::ContextError(e.to_string()))?;
                
                return Err(error);
            }
        }
        
        Ok(())
    }
    
    /// 스테이지 아이템들 처리
    /// 
    /// # Arguments
    /// * `stage_type` - 스테이지 타입
    /// * `items` - 처리할 아이템들
    /// * `concurrency_limit` - 동시성 제한
    /// * `context` - Actor 컨텍스트
    async fn process_stage_items(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        context: &AppContext,
    ) -> Result<StageResult, StageError> {
        debug!("Processing {} items for stage {:?}", items.len(), stage_type);
        
        // 동시성 제어를 위한 세마포어
        let semaphore = Arc::new(tokio::sync::Semaphore::new(concurrency_limit as usize));
        let mut tasks = Vec::new();
        
        // self의 크롤링 엔진들을 Arc로 복사
        let http_client = self.http_client.clone();
        let data_extractor = self.data_extractor.clone();
        let database_connection = self.database_connection.clone();
        
        // 각 아이템을 병렬로 처리
        for item in items {
            let sem = semaphore.clone();
            let item_clone = item.clone();
            let stage_type_clone = stage_type.clone();
            let http_client_clone = http_client.clone();
            let data_extractor_clone = data_extractor.clone();
            let database_connection_clone = database_connection.clone();
            
            let task = tokio::spawn(async move {
                let _permit = sem.acquire().await.map_err(|e| 
                    StageError::InitializationFailed(format!("Semaphore error: {}", e))
                )?;
                
                // 스테이지별 처리 로직 직접 호출
                Self::process_item_with_engines(
                    stage_type_clone, 
                    item_clone,
                    &http_client_clone,
                    &data_extractor_clone,
                    &database_connection_clone
                ).await
            });
            
            tasks.push(task);
        }
        
        // 모든 태스크 완료 대기
        let mut results = Vec::new();
        for task in tasks {
            match task.await {
                Ok(Ok(result)) => {
                    results.push(result);
                }
                Ok(Err(e)) => {
                    error!("Item processing failed: {}", e);
                    results.push(StageItemResult {
                        item_id: "unknown".to_string(),
                        item_type: StageItemType::Url { url_type: "unknown".to_string() },
                        success: false,
                        error: Some(e.to_string()),
                        duration_ms: 0,
                        retry_count: 0,
                    });
                }
                Err(e) => {
                    error!("Task join error: {}", e);
                    results.push(StageItemResult {
                        item_id: "unknown".to_string(),
                        item_type: StageItemType::Url { url_type: "unknown".to_string() },
                        success: false,
                        error: Some(format!("Task join error: {}", e)),
                        duration_ms: 0,
                        retry_count: 0,
                    });
                }
            }
        }
        
        // 결과 집계
        self.item_results = results;
        self.completed_items = self.item_results.len() as u32;
        self.success_count = self.item_results.iter().filter(|r| r.success).count() as u32;
        self.failure_count = self.item_results.iter().filter(|r| !r.success).count() as u32;
        
        let duration = self.start_time
            .map(|start| start.elapsed())
            .unwrap_or(Duration::ZERO);
        
        Ok(StageResult {
            processed_items: self.completed_items,
            successful_items: self.success_count,
            failed_items: self.failure_count,
            duration_ms: duration.as_millis() as u64,
            details: self.item_results.clone(),
        })
    }
    
    /// 개별 아이템 처리 (제거 예정 - process_item_with_engines 사용)
    /// 
    /// # Arguments
    /// * `stage_type` - 스테이지 타입
    /// * `item` - 처리할 아이템
    async fn process_single_item(
        stage_type: StageType,
        item: StageItem,
    ) -> Result<StageItemResult, StageError> {
        // 임시로 에러 반환 - 실제로는 process_item_with_engines 사용
        Err(StageError::InitializationFailed(
            "process_single_item is deprecated, use process_item_with_engines".to_string()
        ))
    }
    
    // ===== 실제 크롤링 로직 메서드들 =====
    
    /// 실제 상태 확인 수행
    async fn perform_status_check(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        
        debug!("🔍 Performing status check for URL: {}", item.url);
        
        // 기본 GET 요청으로 사이트 접근성 확인
        match client.get(&item.url).await {
            Ok(response) => {
                let status = response.status();
                if status.is_success() {
                    info!("✅ Status check passed for {}: {}", item.url, status);
                    Ok(())
                } else {
                    let error = format!("Status check failed: HTTP {}", status);
                    warn!("❌ {}", error);
                    Err(error)
                }
            }
            Err(e) => {
                let error = format!("Network error during status check: {}", e);
                error!("❌ {}", error);
                Err(error)
            }
        }
    }
    
    /// 실제 리스트 페이지 크롤링 수행
    async fn perform_list_page_crawling(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        let extractor = data_extractor.as_ref()
            .ok_or_else(|| "MatterDataExtractor not initialized".to_string())?;
        
        debug!("🕷️ Performing list page crawling for URL: {}", item.url);
        
        // HTML 페이지 가져오기
        let response = client.get(&item.url).await
            .map_err(|e| format!("Failed to fetch list page: {}", e))?;
        
        let html = response.text().await
            .map_err(|e| format!("Failed to get response text: {}", e))?;
        
        // 제품 URL들 추출
        let product_urls = extractor.extract_product_urls(&html)
            .map_err(|e| format!("Failed to extract product URLs: {}", e))?;
        
        info!("✅ List page crawling completed for {}: found {} product URLs", 
              item.url, product_urls.len());
        
        // TODO: 추출된 URL들을 다음 스테이지로 전달하는 로직 구현 필요
        Ok(())
    }
    
    /// 실제 상품 상세 크롤링 수행
    async fn perform_product_detail_crawling(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        let extractor = data_extractor.as_ref()
            .ok_or_else(|| "MatterDataExtractor not initialized".to_string())?;
        
        debug!("📝 Performing product detail crawling for URL: {}", item.url);
        
        // HTML 페이지 가져오기
        let response = client.get(&item.url).await
            .map_err(|e| format!("Failed to fetch product detail page: {}", e))?;
        
        let html = response.text().await
            .map_err(|e| format!("Failed to get response text: {}", e))?;
        
        // 제품 상세 정보 추출
        let product_data = extractor.extract_product_details(&html)
            .map_err(|e| format!("Failed to extract product details: {}", e))?;
        
        info!("✅ Product detail crawling completed for {}: extracted data for {}", 
              item.url, product_data.product_name.as_deref().unwrap_or("unknown"));
        
        // TODO: 추출된 데이터를 다음 스테이지로 전달하는 로직 구현 필요
        Ok(())
    }
    
    /// 실제 데이터 검증 수행
    async fn perform_data_validation(item: &StageItem) -> Result<(), String> {
        debug!("🔍 Performing data validation for item: {}", item.id);
        
        // TODO: 실제 데이터 검증 로직 구현
        // 현재는 기본적인 검증만 수행
        
        if item.url.is_empty() {
            return Err("Invalid item: empty URL".to_string());
        }
        
        if !item.url.starts_with("http") {
            return Err("Invalid item: malformed URL".to_string());
        }
        
        info!("✅ Data validation passed for item: {}", item.id);
        Ok(())
    }
    
    /// 실제 데이터베이스 저장 수행
    async fn perform_database_storage(
        item: &StageItem, 
        database_connection: &Option<Arc<DatabaseConnection>>
    ) -> Result<(), String> {
        let db = database_connection.as_ref()
            .ok_or_else(|| "DatabaseConnection not initialized".to_string())?;
        
        debug!("💾 Performing database storage for item: {}", item.id);
        
        // TODO: 실제 데이터베이스 저장 로직 구현
        // 현재는 연결 테스트만 수행
        
        // 데이터베이스 연결 확인
        // 실제 저장 로직은 추출된 ProductData가 필요함
        
        info!("✅ Database storage completed for item: {}", item.id);
        Ok(())
    }
    
    // ===== 기존 시뮬레이션 메서드들 (제거 예정) =====
    async fn simulate_list_page_processing(item: &StageItem) -> Result<(), String> {
        // 임시: 간단한 처리 시뮬레이션
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // 90% 성공률 시뮬레이션
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated network error".to_string())
        }
    }
    
    /// 상품 상세 처리 시뮬레이션 (Phase 3 임시)
    async fn simulate_product_detail_processing(item: &StageItem) -> Result<(), String> {
        // 임시: 간단한 처리 시뮬레이션
        tokio::time::sleep(Duration::from_millis(200)).await;
        
        // 85% 성공률 시뮬레이션
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 8 {
            Ok(())
        } else {
            Err("Simulated parsing error".to_string())
        }
    }
    
    /// 데이터 추출 시뮬레이션 (Phase 3 임시)
    async fn simulate_data_extraction(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(150)).await;
        
        // 90% 성공률 시뮬레이션
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated data extraction error".to_string())
        }
    }
    
    /// 데이터 검증 시뮬레이션 (Phase 3 임시)
    async fn simulate_data_validation(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(30)).await;
        
        // 95% 성공률 시뮬레이션
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated validation error".to_string())
        }
    }
    
    /// 데이터베이스 저장 시뮬레이션 (Phase 3 임시)
    async fn simulate_database_storage(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(80)).await;
        Ok(())
    }
    
    /// 상태 확인 시뮬레이션 (Phase 3 임시)
    async fn simulate_status_check(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(50)).await;
        
        // 98% 성공률 시뮬레이션
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated status check error".to_string())
        }
    }
    
    /// 스테이지 정리
    fn cleanup_stage(&mut self) {
        self.stage_id = None;
        self.stage_type = None;
        self.state = StageState::Idle;
        self.start_time = None;
        self.total_items = 0;
        self.completed_items = 0;
        self.success_count = 0;
        self.failure_count = 0;
        self.skipped_count = 0;
        self.item_results.clear();
    }
    
    /// 진행 상황 계산
    /// 
    /// # Returns
    /// * `f64` - 진행률 (0.0 ~ 1.0)
    fn calculate_progress(&self) -> f64 {
        if self.total_items == 0 {
            0.0
        } else {
            f64::from(self.completed_items) / f64::from(self.total_items)
        }
    }
    
    /// 성공률 계산
    /// 
    /// # Returns
    /// * `f64` - 성공률 (0.0 ~ 1.0)
    fn calculate_success_rate(&self) -> f64 {
        if self.completed_items == 0 {
            0.0
        } else {
            f64::from(self.success_count) / f64::from(self.completed_items)
        }
    }
}

#[async_trait::async_trait]
impl Actor for StageActor {
    type Command = ActorCommand;
    type Error = ActorError;

    fn actor_id(&self) -> &str {
        self.stage_id.as_deref().unwrap_or("unknown")
    }

    fn actor_type(&self) -> ActorType {
        ActorType::Stage
    }    async fn run(
        &mut self,
        mut context: AppContext,
        mut command_rx: mpsc::Receiver<Self::Command>,
    ) -> Result<(), Self::Error> {
        info!("🎯 StageActor {} starting execution loop", self.actor_id);
        
        loop {
            tokio::select! {
                // 명령 처리
                command = command_rx.recv() => {
                    match command {
                        Some(cmd) => {
                            debug!("📨 StageActor {} received command: {:?}", self.actor_id, cmd);
                            
                            match cmd {
                                ActorCommand::ExecuteStage { 
                                    stage_type, 
                                    items, 
                                    concurrency_limit, 
                                    timeout_secs 
                                } => {
                                    if let Err(e) = self.handle_execute_stage(
                                        stage_type, 
                                        items, 
                                        concurrency_limit, 
                                        timeout_secs, 
                                        &context
                                    ).await {
                                        error!("Failed to execute stage: {}", e);
                                    }
                                }
                                
                                ActorCommand::Shutdown => {
                                    info!("🛑 StageActor {} received shutdown command", self.actor_id);
                                    break;
                                }
                                
                                _ => {
                                    debug!("StageActor {} ignoring non-stage command", self.actor_id);
                                }
                            }
                        }
                        None => {
                            warn!("📪 StageActor {} command channel closed", self.actor_id);
                            break;
                        }
                    }
                }
                
                // 취소 신호 확인
                _ = context.cancellation_token.changed() => {
                    if *context.cancellation_token.borrow() {
                        warn!("🚫 StageActor {} received cancellation signal", self.actor_id);
                        break;
                    }
                }
            }
        }
        
        info!("🏁 StageActor {} execution loop ended", self.actor_id);
        Ok(())
    }
    
    async fn health_check(&self) -> Result<ActorHealth, Self::Error> {
        let status = match &self.state {
            StageState::Idle => ActorStatus::Healthy,
            StageState::Processing => ActorStatus::Healthy,
            StageState::Completed => ActorStatus::Healthy,
            StageState::Timeout => ActorStatus::Degraded { 
                reason: "Stage timed out".to_string(),
                since: Utc::now(),
            },
            StageState::Failed { error } => ActorStatus::Unhealthy { 
                error: error.clone(),
                since: Utc::now(),
            },
            _ => ActorStatus::Degraded { 
                reason: format!("In transition state: {:?}", self.state),
                since: Utc::now(),
            },
        };
        
        Ok(ActorHealth {
            actor_id: self.stage_id.clone().unwrap_or_default(),
            actor_type: ActorType::Stage,
            status,
            last_activity: Utc::now(),
            memory_usage_mb: 0, // TODO: 실제 메모리 사용량 계산
            active_tasks: if matches!(self.state, StageState::Processing) { 
                self.total_items - self.completed_items 
            } else { 
                0 
            },
            commands_processed: 0, // TODO: 실제 처리된 명령 수 계산
            errors_count: 0, // TODO: 실제 에러 수 계산
            avg_command_processing_time_ms: 0.0, // TODO: 실제 평균 처리 시간 계산
            metadata: serde_json::json!({
                "stage_id": self.stage_id,
                "stage_type": self.stage_type,
                "state": format!("{:?}", self.state),
                "total_items": self.total_items,
                "completed_items": self.completed_items,
                "success_count": self.success_count,
                "failure_count": self.failure_count,
                "skipped_count": self.skipped_count,
                "progress": self.calculate_progress(),
                "success_rate": self.calculate_success_rate()
            }).to_string(),
        })
    }
    
    async fn shutdown(&mut self) -> Result<(), Self::Error> {
        info!("🔌 StageActor {} shutting down", self.actor_id);
        
        // 활성 스테이지가 있다면 정리
        if self.stage_id.is_some() {
            warn!("Cleaning up active stage during shutdown");
            self.cleanup_stage();
        }
        
        Ok(())
    }
}
