//! StageActor: ê°œë³„ ìŠ¤í…Œì´ì§€ ì‘ì—… ì²˜ë¦¬ Actor
//! 
//! Phase 3: Actor êµ¬í˜„ - ìŠ¤í…Œì´ì§€ ë ˆë²¨ ì‘ì—… ì‹¤í–‰ ë° ê´€ë¦¬
//! Modern Rust 2024 ì¤€ìˆ˜: í•¨ìˆ˜í˜• ì›ì¹™, ëª…ì‹œì  ì˜ì¡´ì„±, ìƒíƒœ ìµœì†Œí™”

#![warn(clippy::all, clippy::pedantic, clippy::nursery)]
#![deny(clippy::unwrap_used, clippy::expect_used, clippy::panic)]

use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use tokio::time::timeout;
use tracing::{info, warn, error, debug};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::ne    /// í¬ë¡¤ë§ ì—”ì§„ê³¼ í•¨ê»˜ ë‹¨ì¼ ì•„ì´í…œ ì²˜ë¦¬ (ì •ì  ë©”ì„œë“œ)
    /// 
    /// # Arguments
    /// * `stage_type` - ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `item` - ì²˜ë¦¬í•  ì•„ì´í…œ
    /// * `http_client` - HTTP í´ë¼ì´ì–¸íŠ¸
    /// * `data_extractor` - ë°ì´í„° ì¶”ì¶œê¸°
    /// * `database_connection` - ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
    async fn process_item_with_engines(
        stage_type: StageType,
        item: StageItem,
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>,
        database_connection: &Option<Arc<DatabaseConnection>>,
    ) -> Result<StageItemResult, StageError> {
        let start_time = Instant::now();
        
        debug!("Processing item {} for stage {:?}", item.id, stage_type);
        
        // ìŠ¤í…Œì´ì§€ íƒ€ì…ë³„ ì²˜ë¦¬ ë¡œì§
        let success = match stage_type {
            StageType::StatusCheck => {
                // âœ… ì‹¤ì œ ìƒíƒœ í™•ì¸ ë¡œì§
                Self::perform_status_check(&item, http_client).await
            }
            StageType::ListPageCrawling => {
                // âœ… ì‹¤ì œ ë¦¬ìŠ¤íŠ¸ í˜ì´ì§€ í¬ë¡¤ë§ ë¡œì§
                Self::perform_list_page_crawling(&item, http_client, data_extractor).await
            }
            StageType::ProductDetailCrawling => {
                // âœ… ì‹¤ì œ ìƒí’ˆ ìƒì„¸ í¬ë¡¤ë§ ë¡œì§
                Self::perform_product_detail_crawling(&item, http_client, data_extractor).await
            }
            StageType::DataValidation => {
                // âœ… ì‹¤ì œ ë°ì´í„° ê²€ì¦ ë¡œì§
                Self::perform_data_validation(&item).await
            }
            StageType::DataSaving => {
                // âœ… ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ë¡œì§
                Self::perform_database_storage(&item, database_connection).await
            }
        };
        
        let duration = start_time.elapsed();
        
        match success {
            Ok(()) => Ok(StageItemResult {
                item_id: item.id,
                item_type: item.item_type,
                success: true,
                error: None,
                duration_ms: duration.as_millis() as u64,
                retry_count: 0,
            }),
            Err(error) => Ok(StageItemResult {
                item_id: item.id.clone(),
                item_type: item.item_type,
                success: false,
                error: Some(error.clone()),
                duration_ms: duration.as_millis() as u64,
                retry_count: 0,
            }),
        }
    }
    
    /// ë‹¨ì¼ ì•„ì´í…œ ì²˜ë¦¬ (ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ)
    /// 
    /// # Arguments
    /// * `stage_type` - ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `item` - ì²˜ë¦¬í•  ì•„ì´í…œ
    async fn process_single_item(
        &self,
        stage_type: StageType,
        item: StageItem,
    ) -> Result<StageItemResult, StageError> {cture::actors::types::{StageItemResult, StageItemType};

use super::traits::{Actor, ActorHealth, ActorStatus, ActorType};
use super::types::{ActorCommand, StageType, StageItem, StageResult, ActorError};
use crate::new_architecture::channels::types::AppEvent;
use crate::new_architecture::context::{AppContext, EventEmitter};

// ì‹¤ì œ í¬ë¡¤ë§ ì—”ì§„ import ì¶”ê°€
use crate::infrastructure::{HttpClient, MatterDataExtractor, DatabaseConnection};
use crate::domain::value_objects::ProductData;

/// StageActor: ê°œë³„ ìŠ¤í…Œì´ì§€ ì‘ì—…ì˜ ì‹¤í–‰ ë° ê´€ë¦¬
/// 
/// ì±…ì„:
/// - íŠ¹ì • ìŠ¤í…Œì´ì§€ íƒ€ì…ì˜ ì‘ì—… ì‹¤í–‰
/// - ì•„ì´í…œë³„ ì²˜ë¦¬ ë° ê²°ê³¼ ìˆ˜ì§‘
/// - ìŠ¤í…Œì´ì§€ ë ˆë²¨ ì´ë²¤íŠ¸ ë°œí–‰
/// - íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„ ë¡œì§ ê´€ë¦¬
#[derive(Debug)]
pub struct StageActor {
    /// Actor ê³ ìœ  ì‹ë³„ì
    actor_id: String,
    /// ë°°ì¹˜ ID (OneShot í˜¸í™˜ì„±)
    pub batch_id: String,
    /// í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ìŠ¤í…Œì´ì§€ ID
    stage_id: Option<String>,
    /// ìŠ¤í…Œì´ì§€ íƒ€ì…
    stage_type: Option<StageType>,
    /// ìŠ¤í…Œì´ì§€ ìƒíƒœ
    state: StageState,
    /// ìŠ¤í…Œì´ì§€ ì‹œì‘ ì‹œê°„
    start_time: Option<Instant>,
    /// ì´ ì•„ì´í…œ ìˆ˜
    total_items: u32,
    /// ì²˜ë¦¬ ì™„ë£Œëœ ì•„ì´í…œ ìˆ˜
    completed_items: u32,
    /// ì„±ê³µí•œ ì•„ì´í…œ ìˆ˜
    success_count: u32,
    /// ì‹¤íŒ¨í•œ ì•„ì´í…œ ìˆ˜
    failure_count: u32,
    /// ìŠ¤í‚¤í•‘ëœ ì•„ì´í…œ ìˆ˜
    skipped_count: u32,
    /// ì²˜ë¦¬ ê²°ê³¼ë“¤
    item_results: Vec<StageItemResult>,
    
    // âœ… ì‹¤ì œ í¬ë¡¤ë§ ì—”ì§„ ì˜ì¡´ì„± ì¶”ê°€
    /// HTTP í´ë¼ì´ì–¸íŠ¸ (ì‹¤ì œ ì›¹ ìš”ì²­)
    http_client: Option<Arc<HttpClient>>,
    /// ë°ì´í„° ì¶”ì¶œê¸° (HTML íŒŒì‹±)
    data_extractor: Option<Arc<MatterDataExtractor>>,
    /// ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° (ë°ì´í„° ì €ì¥)
    database_connection: Option<Arc<DatabaseConnection>>,
}

/// ìŠ¤í…Œì´ì§€ ìƒíƒœ ì—´ê±°í˜•
#[derive(Debug, Clone, PartialEq)]
pub enum StageState {
    Idle,
    Starting,
    Processing,
    Completing,
    Completed,
    Failed { error: String },
    Timeout,
}

/// ìŠ¤í…Œì´ì§€ ê´€ë ¨ ì—ëŸ¬ íƒ€ì…
#[derive(Debug, thiserror::Error)]
pub enum StageError {
    #[error("Stage initialization failed: {0}")]
    InitializationFailed(String),
    
    #[error("Stage already processing: {0}")]
    AlreadyProcessing(String),
    
    #[error("Stage not found: {0}")]
    StageNotFound(String),
    
    #[error("Invalid stage configuration: {0}")]
    InvalidConfiguration(String),
    
    #[error("Stage processing timeout: {timeout_secs}s")]
    ProcessingTimeout { timeout_secs: u64 },
    
    #[error("Item processing failed: {item_id} - {error}")]
    ItemProcessingFailed { item_id: String, error: String },
    
    #[error("Context communication error: {0}")]
    ContextError(String),
    
    #[error("Unsupported stage type: {0:?}")]
    UnsupportedStageType(StageType),
}

impl StageActor {
    /// ìƒˆë¡œìš´ StageActor ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    /// 
    /// # Arguments
    /// * `actor_id` - Actor ê³ ìœ  ì‹ë³„ì
    /// 
    /// # Returns
    /// * `Self` - ìƒˆë¡œìš´ StageActor ì¸ìŠ¤í„´ìŠ¤
    pub fn new(actor_id: String) -> Self {
        let batch_id = Uuid::new_v4().to_string();
        Self {
            actor_id,
            batch_id,
            stage_id: None,
            stage_type: None,
            state: StageState::Idle,
            start_time: None,
            total_items: 0,
            completed_items: 0,
            success_count: 0,
            failure_count: 0,
            skipped_count: 0,
            item_results: Vec::new(),
            
            // ì‹¤ì œ í¬ë¡¤ë§ ì—”ì§„ ì´ˆê¸°í™” (Noneìœ¼ë¡œ ì‹œì‘, ë‚˜ì¤‘ì— ì„¤ì •)
            http_client: None,
            data_extractor: None,
            database_connection: None,
        }
    }
    
    /// OneShot Actor ì‹œìŠ¤í…œ í˜¸í™˜ì„±ì„ ìœ„í•œ ìƒì„±ì
    /// 
    /// # Arguments
    /// * `batch_id` - ë°°ì¹˜ ì‹ë³„ì
    /// * `config` - ì‹œìŠ¤í…œ ì„¤ì •
    /// * `total_pages` - ì´ í˜ì´ì§€ ìˆ˜ (ì„ íƒì )
    /// * `products_on_last_page` - ë§ˆì§€ë§‰ í˜ì´ì§€ ì œí’ˆ ìˆ˜ (ì„ íƒì )
    /// 
    /// # Returns
    /// * `Self` - ìƒˆë¡œìš´ StageActor ì¸ìŠ¤í„´ìŠ¤
    pub fn new_with_oneshot(
        batch_id: String, 
        _config: Arc<crate::new_architecture::config::SystemConfig>,
        _total_pages: u32,
        _products_on_last_page: u32
    ) -> Self {
        let actor_id = Uuid::new_v4().to_string();
        Self {
            actor_id,
            batch_id,
            stage_id: None,
            stage_type: None,
            state: StageState::Idle,
            start_time: None,
            total_items: 0,
            completed_items: 0,
            success_count: 0,
            failure_count: 0,
            skipped_count: 0,
            item_results: Vec::new(),
            
            // ì‹¤ì œ í¬ë¡¤ë§ ì—”ì§„ ì´ˆê¸°í™” (Noneìœ¼ë¡œ ì‹œì‘, ë‚˜ì¤‘ì— ì„¤ì •)
            http_client: None,
            data_extractor: None,
            database_connection: None,
        }
    }
    
    /// ì‹¤ì œ í¬ë¡¤ë§ ì—”ì§„ ì˜ì¡´ì„± ì„¤ì •
    /// 
    /// # Arguments
    /// * `http_client` - HTTP í´ë¼ì´ì–¸íŠ¸
    /// * `data_extractor` - ë°ì´í„° ì¶”ì¶œê¸°
    /// * `database_connection` - ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
    pub fn with_crawling_engines(
        mut self,
        http_client: Arc<HttpClient>,
        data_extractor: Arc<MatterDataExtractor>,
        database_connection: Arc<DatabaseConnection>,
    ) -> Self {
        self.http_client = Some(http_client);
        self.data_extractor = Some(data_extractor);
        self.database_connection = Some(database_connection);
        self
    }
    
    /// í¬ë¡¤ë§ ì—”ì§„ ì´ˆê¸°í™” (ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ)
    pub async fn initialize_default_engines(&mut self) -> Result<(), StageError> {
        // HttpClient ì´ˆê¸°í™”
        let http_client = HttpClient::create_from_global_config()
            .map_err(|e| StageError::InitializationFailed(format!("Failed to create HttpClient: {}", e)))?;
        
        // MatterDataExtractor ì´ˆê¸°í™”  
        let data_extractor = Arc::new(MatterDataExtractor::new());
        
        // DatabaseConnection ì´ˆê¸°í™” (ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ URL ì‚¬ìš©)
        let database_url = std::env::var("DATABASE_URL")
            .unwrap_or_else(|_| "sqlite:./matter_certis.db".to_string());
        let database_connection = DatabaseConnection::new(&database_url).await
            .map_err(|e| StageError::InitializationFailed(format!("Failed to create DatabaseConnection: {}", e)))?;
        
        self.http_client = Some(Arc::new(http_client));
        self.data_extractor = Some(data_extractor);
        self.database_connection = Some(Arc::new(database_connection));
        
        Ok(())
    }
    
    /// ê³µê°œ ìŠ¤í…Œì´ì§€ ì‹¤í–‰ ë©”ì„œë“œ (BatchActorì—ì„œ ì‚¬ìš©)
    /// 
    /// # Arguments
    /// * `stage_type` - ì‹¤í–‰í•  ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `items` - ì²˜ë¦¬í•  ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸
    /// * `concurrency_limit` - ë™ì‹œì„± ì œí•œ
    /// * `timeout_secs` - íƒ€ì„ì•„ì›ƒ (ì´ˆ)
    /// * `context` - Actor ì»¨í…ìŠ¤íŠ¸
    pub async fn execute_stage(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        timeout_secs: u64,
        context: &AppContext,
    ) -> Result<StageResult, StageError> {
        self.handle_execute_stage(
            stage_type.clone(),
            items,
            concurrency_limit,
            timeout_secs,
            context,
        ).await?;
        
        Ok(StageResult {
            processed_items: self.completed_items,
            successful_items: self.success_count,
            failed_items: self.failure_count,
            duration_ms: self.start_time.map(|start| start.elapsed().as_millis() as u64).unwrap_or(0),
            details: self.item_results.clone(),
        })
    }
    
    /// ìŠ¤í…Œì´ì§€ ì‹¤í–‰ ì²˜ë¦¬
    /// 
    /// # Arguments
    /// * `stage_type` - ì‹¤í–‰í•  ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `items` - ì²˜ë¦¬í•  ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸
    /// * `concurrency_limit` - ë™ì‹œì„± ì œí•œ
    /// * `timeout_secs` - íƒ€ì„ì•„ì›ƒ (ì´ˆ)
    /// * `context` - Actor ì»¨í…ìŠ¤íŠ¸
    async fn handle_execute_stage(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        timeout_secs: u64,
        context: &AppContext,
    ) -> Result<(), StageError> {
        // ìƒíƒœ ê²€ì¦
        if !matches!(self.state, StageState::Idle) {
            return Err(StageError::AlreadyProcessing(
                self.stage_id.clone().unwrap_or_else(|| "unknown".to_string())
            ));
        }
        
        let stage_id = Uuid::new_v4().to_string();
        
        info!("ğŸ¯ StageActor {} executing stage {:?} with {} items", 
              self.actor_id, stage_type, items.len());
        
        // ìƒíƒœ ì´ˆê¸°í™”
        self.stage_id = Some(stage_id.clone());
        self.stage_type = Some(stage_type.clone());
        self.state = StageState::Starting;
        self.start_time = Some(Instant::now());
        self.total_items = items.len() as u32;
        self.completed_items = 0;
        self.success_count = 0;
        self.failure_count = 0;
        self.skipped_count = 0;
        self.item_results.clear();
        
        // ìŠ¤í…Œì´ì§€ ì‹œì‘ ì´ë²¤íŠ¸ ë°œí–‰
        let start_event = AppEvent::StageStarted {
            stage_type: stage_type.clone(),
            session_id: context.session_id.clone(),
            items_count: items.len() as u32,
            timestamp: Utc::now(),
        };
        
        context.emit_event(start_event).await
            .map_err(|e| StageError::ContextError(e.to_string()))?;
        
        // ìƒíƒœë¥¼ Processingìœ¼ë¡œ ì „í™˜
        self.state = StageState::Processing;
        
        // íƒ€ì„ì•„ì›ƒê³¼ í•¨ê»˜ ìŠ¤í…Œì´ì§€ ì²˜ë¦¬
        let processing_result = timeout(
            Duration::from_secs(timeout_secs),
            self.process_stage_items(stage_type.clone(), items, concurrency_limit, context)
        ).await;
        
        match processing_result {
            Ok(result) => {
                match result {
                    Ok(stage_result) => {
                        self.state = StageState::Completed;
                        
                        // ì™„ë£Œ ì´ë²¤íŠ¸ ë°œí–‰
                        let completion_event = AppEvent::StageCompleted {
                            stage_type: stage_type.clone(),
                            session_id: context.session_id.clone(),
                            result: stage_result,
                            timestamp: Utc::now(),
                        };
                        
                        context.emit_event(completion_event).await
                            .map_err(|e| StageError::ContextError(e.to_string()))?;
                        
                        info!("âœ… Stage {:?} completed successfully: {}/{} items processed", 
                              stage_type, self.success_count, self.total_items);
                    }
                    Err(e) => {
                        let error_msg = e.to_string();
                        self.state = StageState::Failed { error: error_msg.clone() };
                        
                        // ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë°œí–‰
                        let failure_event = AppEvent::StageFailed {
                            stage_type: stage_type.clone(),
                            session_id: context.session_id.clone(),
                            error: error_msg,
                            timestamp: Utc::now(),
                        };
                        
                        context.emit_event(failure_event).await
                            .map_err(|e| StageError::ContextError(e.to_string()))?;
                        
                        return Err(e);
                    }
                }
            }
            Err(_) => {
                // íƒ€ì„ì•„ì›ƒ ë°œìƒ
                self.state = StageState::Timeout;
                
                let error = StageError::ProcessingTimeout { timeout_secs };
                
                // íƒ€ì„ì•„ì›ƒ ì´ë²¤íŠ¸ ë°œí–‰
                let timeout_event = AppEvent::StageFailed {
                    stage_type: stage_type.clone(),
                    session_id: context.session_id.clone(),
                    error: error.to_string(),
                    timestamp: Utc::now(),
                };
                
                context.emit_event(timeout_event).await
                    .map_err(|e| StageError::ContextError(e.to_string()))?;
                
                return Err(error);
            }
        }
        
        Ok(())
    }
    
    /// ìŠ¤í…Œì´ì§€ ì•„ì´í…œë“¤ ì²˜ë¦¬
    /// 
    /// # Arguments
    /// * `stage_type` - ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `items` - ì²˜ë¦¬í•  ì•„ì´í…œë“¤
    /// * `concurrency_limit` - ë™ì‹œì„± ì œí•œ
    /// * `context` - Actor ì»¨í…ìŠ¤íŠ¸
    async fn process_stage_items(
        &mut self,
        stage_type: StageType,
        items: Vec<StageItem>,
        concurrency_limit: u32,
        context: &AppContext,
    ) -> Result<StageResult, StageError> {
        debug!("Processing {} items for stage {:?}", items.len(), stage_type);
        
        // ë™ì‹œì„± ì œì–´ë¥¼ ìœ„í•œ ì„¸ë§ˆí¬ì–´
        let semaphore = Arc::new(tokio::sync::Semaphore::new(concurrency_limit as usize));
        let mut tasks = Vec::new();
        
        // selfì˜ í¬ë¡¤ë§ ì—”ì§„ë“¤ì„ Arcë¡œ ë³µì‚¬
        let http_client = self.http_client.clone();
        let data_extractor = self.data_extractor.clone();
        let database_connection = self.database_connection.clone();
        
        // ê° ì•„ì´í…œì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬
        for item in items {
            let sem = semaphore.clone();
            let item_clone = item.clone();
            let stage_type_clone = stage_type.clone();
            let http_client_clone = http_client.clone();
            let data_extractor_clone = data_extractor.clone();
            let database_connection_clone = database_connection.clone();
            
            let task = tokio::spawn(async move {
                let _permit = sem.acquire().await.map_err(|e| 
                    StageError::InitializationFailed(format!("Semaphore error: {}", e))
                )?;
                
                // ìŠ¤í…Œì´ì§€ë³„ ì²˜ë¦¬ ë¡œì§ ì§ì ‘ í˜¸ì¶œ
                Self::process_item_with_engines(
                    stage_type_clone, 
                    item_clone,
                    &http_client_clone,
                    &data_extractor_clone,
                    &database_connection_clone
                ).await
            });
            
            tasks.push(task);
        }
        
        // ëª¨ë“  íƒœìŠ¤í¬ ì™„ë£Œ ëŒ€ê¸°
        let mut results = Vec::new();
        for task in tasks {
            match task.await {
                Ok(Ok(result)) => {
                    results.push(result);
                }
                Ok(Err(e)) => {
                    error!("Item processing failed: {}", e);
                    results.push(StageItemResult {
                        item_id: "unknown".to_string(),
                        item_type: StageItemType::Url { url_type: "unknown".to_string() },
                        success: false,
                        error: Some(e.to_string()),
                        duration_ms: 0,
                        retry_count: 0,
                    });
                }
                Err(e) => {
                    error!("Task join error: {}", e);
                    results.push(StageItemResult {
                        item_id: "unknown".to_string(),
                        item_type: StageItemType::Url { url_type: "unknown".to_string() },
                        success: false,
                        error: Some(format!("Task join error: {}", e)),
                        duration_ms: 0,
                        retry_count: 0,
                    });
                }
            }
        }
        
        // ê²°ê³¼ ì§‘ê³„
        self.item_results = results;
        self.completed_items = self.item_results.len() as u32;
        self.success_count = self.item_results.iter().filter(|r| r.success).count() as u32;
        self.failure_count = self.item_results.iter().filter(|r| !r.success).count() as u32;
        
        let duration = self.start_time
            .map(|start| start.elapsed())
            .unwrap_or(Duration::ZERO);
        
        Ok(StageResult {
            processed_items: self.completed_items,
            successful_items: self.success_count,
            failed_items: self.failure_count,
            duration_ms: duration.as_millis() as u64,
            details: self.item_results.clone(),
        })
    }
    
    /// ê°œë³„ ì•„ì´í…œ ì²˜ë¦¬ (ì œê±° ì˜ˆì • - process_item_with_engines ì‚¬ìš©)
    /// 
    /// # Arguments
    /// * `stage_type` - ìŠ¤í…Œì´ì§€ íƒ€ì…
    /// * `item` - ì²˜ë¦¬í•  ì•„ì´í…œ
    async fn process_single_item(
        stage_type: StageType,
        item: StageItem,
    ) -> Result<StageItemResult, StageError> {
        // ì„ì‹œë¡œ ì—ëŸ¬ ë°˜í™˜ - ì‹¤ì œë¡œëŠ” process_item_with_engines ì‚¬ìš©
        Err(StageError::InitializationFailed(
            "process_single_item is deprecated, use process_item_with_engines".to_string()
        ))
    }
    
    // ===== ì‹¤ì œ í¬ë¡¤ë§ ë¡œì§ ë©”ì„œë“œë“¤ =====
    
    /// ì‹¤ì œ ìƒíƒœ í™•ì¸ ìˆ˜í–‰
    async fn perform_status_check(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        
        debug!("ğŸ” Performing status check for URL: {}", item.url);
        
        // ê¸°ë³¸ GET ìš”ì²­ìœ¼ë¡œ ì‚¬ì´íŠ¸ ì ‘ê·¼ì„± í™•ì¸
        match client.get(&item.url).await {
            Ok(response) => {
                let status = response.status();
                if status.is_success() {
                    info!("âœ… Status check passed for {}: {}", item.url, status);
                    Ok(())
                } else {
                    let error = format!("Status check failed: HTTP {}", status);
                    warn!("âŒ {}", error);
                    Err(error)
                }
            }
            Err(e) => {
                let error = format!("Network error during status check: {}", e);
                error!("âŒ {}", error);
                Err(error)
            }
        }
    }
    
    /// ì‹¤ì œ ë¦¬ìŠ¤íŠ¸ í˜ì´ì§€ í¬ë¡¤ë§ ìˆ˜í–‰
    async fn perform_list_page_crawling(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        let extractor = data_extractor.as_ref()
            .ok_or_else(|| "MatterDataExtractor not initialized".to_string())?;
        
        debug!("ğŸ•·ï¸ Performing list page crawling for URL: {}", item.url);
        
        // HTML í˜ì´ì§€ ê°€ì ¸ì˜¤ê¸°
        let response = client.get(&item.url).await
            .map_err(|e| format!("Failed to fetch list page: {}", e))?;
        
        let html = response.text().await
            .map_err(|e| format!("Failed to get response text: {}", e))?;
        
        // ì œí’ˆ URLë“¤ ì¶”ì¶œ
        let product_urls = extractor.extract_product_urls(&html)
            .map_err(|e| format!("Failed to extract product URLs: {}", e))?;
        
        info!("âœ… List page crawling completed for {}: found {} product URLs", 
              item.url, product_urls.len());
        
        // TODO: ì¶”ì¶œëœ URLë“¤ì„ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì „ë‹¬í•˜ëŠ” ë¡œì§ êµ¬í˜„ í•„ìš”
        Ok(())
    }
    
    /// ì‹¤ì œ ìƒí’ˆ ìƒì„¸ í¬ë¡¤ë§ ìˆ˜í–‰
    async fn perform_product_detail_crawling(
        item: &StageItem, 
        http_client: &Option<Arc<HttpClient>>,
        data_extractor: &Option<Arc<MatterDataExtractor>>
    ) -> Result<(), String> {
        let client = http_client.as_ref()
            .ok_or_else(|| "HttpClient not initialized".to_string())?;
        let extractor = data_extractor.as_ref()
            .ok_or_else(|| "MatterDataExtractor not initialized".to_string())?;
        
        debug!("ğŸ“ Performing product detail crawling for URL: {}", item.url);
        
        // HTML í˜ì´ì§€ ê°€ì ¸ì˜¤ê¸°
        let response = client.get(&item.url).await
            .map_err(|e| format!("Failed to fetch product detail page: {}", e))?;
        
        let html = response.text().await
            .map_err(|e| format!("Failed to get response text: {}", e))?;
        
        // ì œí’ˆ ìƒì„¸ ì •ë³´ ì¶”ì¶œ
        let product_data = extractor.extract_product_details(&html)
            .map_err(|e| format!("Failed to extract product details: {}", e))?;
        
        info!("âœ… Product detail crawling completed for {}: extracted data for {}", 
              item.url, product_data.product_name.as_deref().unwrap_or("unknown"));
        
        // TODO: ì¶”ì¶œëœ ë°ì´í„°ë¥¼ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì „ë‹¬í•˜ëŠ” ë¡œì§ êµ¬í˜„ í•„ìš”
        Ok(())
    }
    
    /// ì‹¤ì œ ë°ì´í„° ê²€ì¦ ìˆ˜í–‰
    async fn perform_data_validation(item: &StageItem) -> Result<(), String> {
        debug!("ğŸ” Performing data validation for item: {}", item.id);
        
        // TODO: ì‹¤ì œ ë°ì´í„° ê²€ì¦ ë¡œì§ êµ¬í˜„
        // í˜„ì¬ëŠ” ê¸°ë³¸ì ì¸ ê²€ì¦ë§Œ ìˆ˜í–‰
        
        if item.url.is_empty() {
            return Err("Invalid item: empty URL".to_string());
        }
        
        if !item.url.starts_with("http") {
            return Err("Invalid item: malformed URL".to_string());
        }
        
        info!("âœ… Data validation passed for item: {}", item.id);
        Ok(())
    }
    
    /// ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ìˆ˜í–‰
    async fn perform_database_storage(
        item: &StageItem, 
        database_connection: &Option<Arc<DatabaseConnection>>
    ) -> Result<(), String> {
        let db = database_connection.as_ref()
            .ok_or_else(|| "DatabaseConnection not initialized".to_string())?;
        
        debug!("ğŸ’¾ Performing database storage for item: {}", item.id);
        
        // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ë¡œì§ êµ¬í˜„
        // í˜„ì¬ëŠ” ì—°ê²° í…ŒìŠ¤íŠ¸ë§Œ ìˆ˜í–‰
        
        // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸
        // ì‹¤ì œ ì €ì¥ ë¡œì§ì€ ì¶”ì¶œëœ ProductDataê°€ í•„ìš”í•¨
        
        info!("âœ… Database storage completed for item: {}", item.id);
        Ok(())
    }
    
    // ===== ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ë©”ì„œë“œë“¤ (ì œê±° ì˜ˆì •) =====
    async fn simulate_list_page_processing(item: &StageItem) -> Result<(), String> {
        // ì„ì‹œ: ê°„ë‹¨í•œ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // 90% ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated network error".to_string())
        }
    }
    
    /// ìƒí’ˆ ìƒì„¸ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜ (Phase 3 ì„ì‹œ)
    async fn simulate_product_detail_processing(item: &StageItem) -> Result<(), String> {
        // ì„ì‹œ: ê°„ë‹¨í•œ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        tokio::time::sleep(Duration::from_millis(200)).await;
        
        // 85% ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 8 {
            Ok(())
        } else {
            Err("Simulated parsing error".to_string())
        }
    }
    
    /// ë°ì´í„° ì¶”ì¶œ ì‹œë®¬ë ˆì´ì…˜ (Phase 3 ì„ì‹œ)
    async fn simulate_data_extraction(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(150)).await;
        
        // 90% ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated data extraction error".to_string())
        }
    }
    
    /// ë°ì´í„° ê²€ì¦ ì‹œë®¬ë ˆì´ì…˜ (Phase 3 ì„ì‹œ)
    async fn simulate_data_validation(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(30)).await;
        
        // 95% ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated validation error".to_string())
        }
    }
    
    /// ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹œë®¬ë ˆì´ì…˜ (Phase 3 ì„ì‹œ)
    async fn simulate_database_storage(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(80)).await;
        Ok(())
    }
    
    /// ìƒíƒœ í™•ì¸ ì‹œë®¬ë ˆì´ì…˜ (Phase 3 ì„ì‹œ)
    async fn simulate_status_check(item: &StageItem) -> Result<(), String> {
        tokio::time::sleep(Duration::from_millis(50)).await;
        
        // 98% ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
        if item.id.chars().last().unwrap_or('0').to_digit(10).unwrap_or(0) < 9 {
            Ok(())
        } else {
            Err("Simulated status check error".to_string())
        }
    }
    
    /// ìŠ¤í…Œì´ì§€ ì •ë¦¬
    fn cleanup_stage(&mut self) {
        self.stage_id = None;
        self.stage_type = None;
        self.state = StageState::Idle;
        self.start_time = None;
        self.total_items = 0;
        self.completed_items = 0;
        self.success_count = 0;
        self.failure_count = 0;
        self.skipped_count = 0;
        self.item_results.clear();
    }
    
    /// ì§„í–‰ ìƒí™© ê³„ì‚°
    /// 
    /// # Returns
    /// * `f64` - ì§„í–‰ë¥  (0.0 ~ 1.0)
    fn calculate_progress(&self) -> f64 {
        if self.total_items == 0 {
            0.0
        } else {
            f64::from(self.completed_items) / f64::from(self.total_items)
        }
    }
    
    /// ì„±ê³µë¥  ê³„ì‚°
    /// 
    /// # Returns
    /// * `f64` - ì„±ê³µë¥  (0.0 ~ 1.0)
    fn calculate_success_rate(&self) -> f64 {
        if self.completed_items == 0 {
            0.0
        } else {
            f64::from(self.success_count) / f64::from(self.completed_items)
        }
    }
}

#[async_trait::async_trait]
impl Actor for StageActor {
    type Command = ActorCommand;
    type Error = ActorError;

    fn actor_id(&self) -> &str {
        self.stage_id.as_deref().unwrap_or("unknown")
    }

    fn actor_type(&self) -> ActorType {
        ActorType::Stage
    }    async fn run(
        &mut self,
        mut context: AppContext,
        mut command_rx: mpsc::Receiver<Self::Command>,
    ) -> Result<(), Self::Error> {
        info!("ğŸ¯ StageActor {} starting execution loop", self.actor_id);
        
        loop {
            tokio::select! {
                // ëª…ë ¹ ì²˜ë¦¬
                command = command_rx.recv() => {
                    match command {
                        Some(cmd) => {
                            debug!("ğŸ“¨ StageActor {} received command: {:?}", self.actor_id, cmd);
                            
                            match cmd {
                                ActorCommand::ExecuteStage { 
                                    stage_type, 
                                    items, 
                                    concurrency_limit, 
                                    timeout_secs 
                                } => {
                                    if let Err(e) = self.handle_execute_stage(
                                        stage_type, 
                                        items, 
                                        concurrency_limit, 
                                        timeout_secs, 
                                        &context
                                    ).await {
                                        error!("Failed to execute stage: {}", e);
                                    }
                                }
                                
                                ActorCommand::Shutdown => {
                                    info!("ğŸ›‘ StageActor {} received shutdown command", self.actor_id);
                                    break;
                                }
                                
                                _ => {
                                    debug!("StageActor {} ignoring non-stage command", self.actor_id);
                                }
                            }
                        }
                        None => {
                            warn!("ğŸ“ª StageActor {} command channel closed", self.actor_id);
                            break;
                        }
                    }
                }
                
                // ì·¨ì†Œ ì‹ í˜¸ í™•ì¸
                _ = context.cancellation_token.changed() => {
                    if *context.cancellation_token.borrow() {
                        warn!("ğŸš« StageActor {} received cancellation signal", self.actor_id);
                        break;
                    }
                }
            }
        }
        
        info!("ğŸ StageActor {} execution loop ended", self.actor_id);
        Ok(())
    }
    
    async fn health_check(&self) -> Result<ActorHealth, Self::Error> {
        let status = match &self.state {
            StageState::Idle => ActorStatus::Healthy,
            StageState::Processing => ActorStatus::Healthy,
            StageState::Completed => ActorStatus::Healthy,
            StageState::Timeout => ActorStatus::Degraded { 
                reason: "Stage timed out".to_string(),
                since: Utc::now(),
            },
            StageState::Failed { error } => ActorStatus::Unhealthy { 
                error: error.clone(),
                since: Utc::now(),
            },
            _ => ActorStatus::Degraded { 
                reason: format!("In transition state: {:?}", self.state),
                since: Utc::now(),
            },
        };
        
        Ok(ActorHealth {
            actor_id: self.stage_id.clone().unwrap_or_default(),
            actor_type: ActorType::Stage,
            status,
            last_activity: Utc::now(),
            memory_usage_mb: 0, // TODO: ì‹¤ì œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê³„ì‚°
            active_tasks: if matches!(self.state, StageState::Processing) { 
                self.total_items - self.completed_items 
            } else { 
                0 
            },
            commands_processed: 0, // TODO: ì‹¤ì œ ì²˜ë¦¬ëœ ëª…ë ¹ ìˆ˜ ê³„ì‚°
            errors_count: 0, // TODO: ì‹¤ì œ ì—ëŸ¬ ìˆ˜ ê³„ì‚°
            avg_command_processing_time_ms: 0.0, // TODO: ì‹¤ì œ í‰ê·  ì²˜ë¦¬ ì‹œê°„ ê³„ì‚°
            metadata: serde_json::json!({
                "stage_id": self.stage_id,
                "stage_type": self.stage_type,
                "state": format!("{:?}", self.state),
                "total_items": self.total_items,
                "completed_items": self.completed_items,
                "success_count": self.success_count,
                "failure_count": self.failure_count,
                "skipped_count": self.skipped_count,
                "progress": self.calculate_progress(),
                "success_rate": self.calculate_success_rate()
            }).to_string(),
        })
    }
    
    async fn shutdown(&mut self) -> Result<(), Self::Error> {
        info!("ğŸ”Œ StageActor {} shutting down", self.actor_id);
        
        // í™œì„± ìŠ¤í…Œì´ì§€ê°€ ìˆë‹¤ë©´ ì •ë¦¬
        if self.stage_id.is_some() {
            warn!("Cleaning up active stage during shutdown");
            self.cleanup_stage();
        }
        
        Ok(())
    }
}
