# v7 아키텍처 vs. 현재 구현: Gap 분석 및 실행 계획 v3

> **문서 목적:** 최신 구현 코드를 최종 설계 문서(`re-arch-plan-final2.md`)와 비교하여, 아키텍처 완성까지의 남은 과제를 명확히 식별하고, 가장 효과적인 다음 단계 실행 계획을 수립합니다.

## 1. Executive Summary (TL;DR)

프로젝트는 Actor 모델의 핵심 뼈대, 즉 `SessionActor`가 `BatchActor`를 생성하고 `oneshot` 채널로 결과를 보고받는 가장 복잡한 상호작용을 성공적으로 구현하며 결정적인 기술적 성과를 달성했습니다.

하지만, 아키텍처의 잠재력을 완전히 실현하기 위해 반드시 해결해야 할 두 가지 핵심 과제가 남아있습니다:

1.  **FE/BE 인터페이스 불일치 (최고 시급):** 백엔드는 `ts-rs`를 통해 타입 공유 준비를 마쳤으나, 프론트엔드는 여전히 수동으로 관리되는 레거시 타입을 사용하고 있습니다. 이는 타입 안정성의 이점을 무효화하고 지속적인 유지보수 비용을 발생시키는 가장 큰 병목입니다.
2.  **지능형 시스템 부재:** 시스템이 스스로 크롤링 계획을 수립하는 "두뇌" 역할의 `CrawlingPlanner` 컴포넌트가 아직 구현되지 않았습니다.

**비유:** "자동차의 프레임과 엔진, 변속기(Actor 구조와 채널)는 성공적으로 결합되었지만, 운전석의 계기판(프론트엔드)은 여전히 구형 모델의 배선을 사용하고 있어 엔진의 최신 정보를 제대로 표시하지 못하고 있으며, 자율 주행을 위한 ECU(Planner)는 아직 탑재되지 않은 상태"입니다.

---

## 2. 아키텍처 핵심 요소별 Gap 심층 분석

### 2.1. 계층적 Actor 모델 및 제어 흐름

-   **[✅ 설계 목표]** `Session` → `Batch` → `Stage`로 이어지는 명확한 책임과 제어의 계층.
-   **[✅ 현재 구현 상태]** `actor_system.rs`에 `SessionActor`, `BatchActor`, `StageActor`의 기본 구조와 `oneshot` 채널을 통한 결과 보고 메커니즘이 성공적으로 구현되었습니다. 이는 설계의 가장 복잡한 구조적 뼈대를 검증한 것입니다.
-   **[⚠️ GAP 분석]**
    -   **`AsyncTask` 추상화 부재:** 최소 작업 단위가 별도의 `AsyncTask`로 추상화되지 않고 `StageActor` 내부에 혼재되어 있습니다.
    -   **모듈 분리 필요:** 모든 Actor가 단일 파일(`actor_system.rs`)에 존재하여, Modern Rust 2024의 모듈화 가이드라인을 준수하고 가독성을 높이기 위한 분리가 필요합니다.
    -   **결론:** 구조의 핵심은 완성되었으나, 코드 품질과 유지보수성 향상을 위한 리팩토링이 필요합니다.

### 2.2. 지능형 계획 수립 (`CrawlingPlanner`)

-   **[✅ 설계 목표]** `CrawlingPlanner`가 시스템 상태를 분석하여 최적의 크롤링 계획(`BatchPlan`)을 동적으로 생성합니다.
-   **[✅ 현재 구현 상태]** 계획 수립에 필요한 기반 분석 함수들(`crawling_integration.rs` 내)은 구현되어 있습니다.
-   **[⚠️ GAP 분석]**
    -   **`CrawlingPlanner` 컴포넌트 부재:** 분석 함수들을 조합하여 동적인 계획을 수립하는 `CrawlingPlanner`라는 "두뇌" 컴포넌트가 없습니다. 현재는 외부에서 모든 것을 정적으로 결정해주는 "수동 모드"로만 동작합니다.
    -   **결론:** 지능형 시스템으로 나아가기 위한 핵심 로직 구현이 다음 과제입니다.

### 2.3. FE/BE 인터페이스 및 타입 안정성 (`ts-rs`)

-   **[✅ 설계 목표]** `ts-rs`를 통해 Rust 타입을 TypeScript로 자동 생성하고, 프론트엔드는 이 타입만을 사용하여 완전한 타입 안정성을 확보합니다.
-   **[✅ 현재 구현 상태]** 백엔드의 `domain/events/mod.rs` 등에 `#[ts(export)]`가 적용되어 타입 공유 준비가 완료되었습니다.
-   **[⚠️ GAP 분석]**
    -   **프론트엔드의 완전한 미적용:** `crawlerStore.ts`는 자동 생성된 타입을 전혀 사용하지 않고, `src/types/crawling.ts` 등 **수동으로 관리되는 레거시 타입에 100% 의존**하고 있습니다.
    -   **핵심 문제:** 이 Gap은 `ts-rs` 도입의 이점을 완전히 무효화하며, 타입 불일치로 인한 런타임 버그와 불필요한 데이터 변환 로직을 유발하는 **가장 시급하고 중요한 문제입니다.**
    -   **결론:** 백엔드의 견고함이 프론트엔드까지 이어지지 못하게 만드는 가장 큰 병목으로, 최우선으로 해결해야 합니다.

---

## 3. 최종 개선 실행 계획 (Action Plan)

> **우선순위:** 1순위(인터페이스), 2순위(지능), 3순위(구조 개선) 순으로 진행하여 병목을 먼저 해결하고 안정적으로 아키텍처를 완성합니다.

### **[1순위] Phase 1: FE/BE 인터페이스 완전 자동화 (최우선 과제)** 🎯

> **목표:** End-to-End 타입 안정성을 확보하여 개발 안정성을 극대화하고, 모든 후속 개발의 견고한 기반을 마련합니다.

1.  **`ts-rs` 빌드 파이프라인 구축:** `src-tauri/build.rs` 파일을 생성하여 `cargo build` 시 `src/types/generated/index.ts` 파일이 자동으로 생성되도록 설정합니다.
2.  **레거시 타입 완전 제거 및 경로 재설정:**
    -   프론트엔드 프로젝트의 `src/types` 내 수동 타입 파일을 모두 **삭제**합니다.
    -   `tsconfig.json`의 `paths`를 수정하여 `@/types/*` 별칭이 새로 생성된 `src/types/generated/*`를 참조하도록 강제합니다.
3.  **`crawlerStore.ts` 리팩토링:**
    -   자동 생성된 Rust 타입(`StageResult`, `AppEvent` 등)을 직접 `import`하여 `CrawlerState`를 재정의합니다.
    -   백엔드 이벤트 구조에 맞춰 상태 관리 로직을 직접적으로 수정하고, 모든 불필요한 데이터 변환 로직을 제거합니다.

### **[2순위] Phase 2: 아키텍처의 "두뇌" 구현** 🧠

> **목표:** 시스템이 스스로 판단하고 계획을 수립하는 지능을 부여하여 "자동 모드"를 활성화합니다.

1.  **`CrawlingPlanner` 구현:**
    -   `crawling_integration.rs`에 이미 존재하는 분석 함수들을 사용하는 `CrawlingPlanner` 구조체를 구현합니다.
    -   `plan()` 메서드에서 분석 결과를 바탕으로 최적의 `Vec<BatchPlan>`을 동적으로 생성하는 로직을 작성합니다.
2.  **`SessionActor`와 연동:**
    -   `SessionActor`가 `StartCrawling` 명령을 받을 때, 정적인 파라미터를 사용하는 대신 `CrawlingPlanner`를 호출하여 동적으로 생성된 계획을 받아오도록 수정합니다.

### **[3순위] Phase 3: Actor 모델 구조 개선 (코드 품질 향상)** 🧹

> **목표:** 코드의 가독성과 유지보수성을 높여 Modern Rust 2024 가이드라인을 완벽하게 준수합니다.

1.  **Actor 파일 분리:** `actor_system.rs`에 혼재된 `SessionActor`, `BatchActor`, `StageActor`를 각각 `src-tauri/src/actors/session.rs`, `src-tauri/src/actors/batch.rs` 등의 개별 파일로 분리합니다.
2.  **`AsyncTask` 추상화 (선택적):** `StageActor` 내부의 `process_single_item_with_result` 로직을 별도의 `AsyncTask` 구조체나 함수로 분리하여, 최소 실행 단위의 책임을 명확히 합니다.

---

## 4. 결론

현재 프로젝트는 기술적으로 가장 어려운 부분을 성공적으로 해결했지만, 아키텍처의 진정한 가치를 실현하기 위해서는 **프론트엔드와 백엔드 간의 인터페이스를 바로잡는 것이 급선무**입니다.

위 계획에 따라 1순위 과제인 **인터페이스 현대화**를 먼저 완료하면, 타입 안정성이라는 튼튼한 기반 위에서 2, 3순위 과제인 **지능형 시스템 구현**과 **코드 구조 개선**을 훨씬 빠르고 안정적으로 진행할 수 있을 것입니다.
