# 크롤링 아키텍처 분석 및 개선 계획

## 1. 문제 상황

새로운 기능 구현 시 기존 크롤링 기능에 회귀(regression)가 반복적으로 발생하는 문제가 식별되었습니다. 이는 시스템의 안정성을 저해하고 유지보수 비용을 증가시키는 주요 원인입니다. 문제의 근본 원인을 파악하고 재발을 방지하기 위해 크롤링 관련 아키텍처와 실제 구현 상태를 점검했습니다.

## 2. 아키텍처 설계 분석

`guide/crawling/matter-certis-v2-batch-crawling-chapter1-architecture.md` 문서를 통해 확인된 크롤링 아키텍처의 핵심 설계 사상은 다음과 같습니다.

*   **상태 중심 설계 (State-Centric Design):** `CrawlingSession`, `SessionState`, `StageProgress` 등을 통해 크롤링의 모든 상태를 명확하게 추적하고 제어합니다.
*   **모듈화된 워크플로우 (Modular Workflow):** 크롤링 프로세스를 'Status Check', 'Data Collection' 등 독립적인 단계(Stage)로 분리하여 유지보수성과 확장성을 높입니다.
*   **상세한 데이터 모델:** 각 단계에서 사용되는 데이터 구조를 구체적으로 정의하여 일관성을 보장합니다.
*   **이벤트 기반 통신 (Event-Driven):** `ProgressUpdate`와 같은 상세한 이벤트를 통해 시스템의 현재 상태를 외부(UI)에 투명하게 전달합니다.

**결론:** 설계된 아키텍처는 매우 견고하고 안정적이며, 확장 가능한 시스템을 구축하기 위한 훌륭한 청사진입니다.

## 3. 실제 구현 상태 분석

`src-tauri/src/domain/entities.rs`와 `src-tauri/src/domain/events.rs` 파일을 분석한 결과, **설계와 구현 사이에 심각한 괴리가 있음**을 확인했습니다.

### 주요 차이점

1.  **핵심 엔티티의 단순화:**
    *   **`CrawlingSession`:** 정교한 상태 관리자(State Manager)가 아닌, 단순 결과 기록용 구조체로 구현되었습니다. 상태를 관리하는 `SessionState` enum 대신 `String` 타입의 `status` 필드를 사용하고 있습니다.
    *   **`StageProgress` 부재:** 아키텍처의 핵심인 '단계(Stage)' 개념과 각 단계의 진행 상태를 추적하는 로직이 구현에서 완전히 누락되었습니다.

2.  **이벤트와 로직의 불일치:**
    *   UI 피드백을 위한 이벤트(`events.rs`)는 설계에 따라 상세하게 정의되어 있습니다.
    *   하지만 이벤트를 발생시켜야 할 실제 비즈니스 로직(`entities.rs`)은 설계대로 구현되지 않아, "겉(이벤트)은 화려하지만 속(로직)은 부실한" 상태입니다.

## 4. 근본 원인 및 문제점

**"설계된 '상태 중심의 모듈화된 아키텍처'가 실제로는 '단일 프로세스 기반의 단순 기록' 방식으로 구현된 것"**이 문제의 근본 원인입니다.

이로 인해 다음과 같은 문제가 발생합니다.

*   **취약성:** 시스템 전체가 강하게 결합되어 작은 변경이 예상치 못한 회귀 문제로 이어집니다.
*   **낮은 확장성:** 기능 추가 및 변경 시 전체 로직을 수정해야 하므로 복잡성이 크게 증가합니다.
*   **추적 및 디버깅의 어려움:** 명확한 상태와 단계 구분이 없어 오류 발생 시 원인 파악이 어렵습니다.

## 5. 해결책: 설계와 구현의 동기화

이 문제를 근본적으로 해결하기 위해 **아키텍처 설계에 맞춰 실제 구현 코드를 리팩토링**하는 것이 시급합니다.

### 리팩토링 목표

1.  **상태 관리 로직 재구축:** 설계 문서에 정의된 `CrawlingSession`, `SessionState`, `StageProgress`, `StageState`를 `domain` 영역에 정확하게 다시 구현하여, 크롤링 프로세스의 상태를 중앙에서 명확하고 안정적으로 관리합니다.
2.  **워크플로우 재정의:** `CrawlingWorkflow`를 구현하여, 크롤링 프로세스를 독립적인 단계(Stage)의 조합으로 재구성합니다.
3.  **이벤트와 로직의 연결:** 재구축된 상태 관리 로직과 워크플로우에 맞춰, 적절한 시점에 정확한 `CrawlingEvent`가 발생하도록 연결합니다.

이 리팩토링을 통해 시스템의 안정성과 예측 가능성을 확보하고, 향후 유지보수 비용을 절감하며, 회귀 문제를 최소화할 수 있습니다.
