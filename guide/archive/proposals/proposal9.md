# Proposal 9: 프로젝트 안정성 및 확장성을 위한 전면적 리팩토링 제안

## 1. 현 상황 진단 및 리팩토링의 필요성

현재 우리 프로젝트는 빠른 개발 과정에서 생성된 다수의 문서와 다양한 구현 스타일이 혼재되어, 기술 부채가 쌓이고 있는 상황입니다.

- **문서 파편화**: `IMPLEMENTATION_SUMMARY_v7.md`, `FINAL_IMPLEMENTATION_SUMMARY.md` 등 유사하지만 다른 버전의 문서들이 많아 어떤 것이 최신인지 파악하기 어렵습니다. 이는 팀의 혼란을 야기하고 잘못된 정보를 기반으로 작업할 위험을 높입니다.
- **코드 구조의 복잡성**: 기능들이 명확한 기준 없이 파일과 함수로 구현되어 있어, 특정 코드를 찾거나 수정하기가 점점 더 어려워지고 있습니다. 이는 버그 발생 가능성을 높이고 새로운 기능 추가 속도를 저하시키는 주요 원인입니다.

**지금이 리팩토링 적기인 이유**:
최근 크롤링 엔진의 핵심 버그(`proposal9.temp.md`에서 분석)를 발견하고 수정하는 과정에 있습니다. 이는 현재 구조의 문제점을 명확히 보여주는 사례입니다. 불안정한 기반 위에서 버그를 수정하고 새 기능을 쌓아 올리는 것은 더 큰 문제를 야기할 수 있습니다. 따라서 **지금 시점에서 구조를 바로잡는 것은 단순한 "정리"가 아니라, 프로젝트의 장기적인 안정성과 개발 효율성을 확보하기 위한 필수적인 투자**입니다.

## 2. 리팩토링 제안

문서와 코드, 두 가지 영역에 대해 아래와 같이 전면적인 구조 개선을 제안합니다.

### 2.1. 문서 구조화: "Single Source of Truth" 원칙 확립

- **목표**: 누구나 필요한 정보를 쉽고 정확하게 찾을 수 있도록, 중앙화되고 정리된 문서 체계를 구축합니다.
- **실행 계획**:
    1. **`docs` 폴더를 공식 문서 저장소로 지정**: 모든 핵심 문서는 `docs` 폴더 아래로 통합합니다.
    2. **문서 분류 및 통합**:
        - **`docs/architecture`**: 아키텍처, 설계 관련 문서 (예: `backend_design_sequence.md`)
        - **`docs/guides`**: 개발 가이드, 설정 방법, 업무 프로세스 등 (예: `development-guide.md`)
        - **`docs/decisions`**: 주요 기술 결정, 회의록 등 (Architecture Decision Records - ADR)
        - **`docs/archive`**: **가장 중요.** 더 이상 유효하지 않거나, 이전 버전의 모든 임시/백업/요약 문서는 이 폴더로 이동시킵니다. (예: `FINAL_IMPLEMENTATION_SUMMARY.md.backup`, `STATUS_CHECK_IMPLEMENTATION.md.backup`, `v7` 등)
    3. **`README.md` 활용**: 각 폴더에 `README.md`를 두어 해당 폴더의 문서 목록과 요약을 제공합니다. 최상위 `README.md`는 전체 프로젝트의 개요와 `docs` 폴더로의 링크를 명확히 안내해야 합니다.

### 2.2. 코드 구조화: 도메인 중심 설계 (Domain-Driven Design) 적용

- **목표**: 기능의 책임과 역할에 따라 코드(Rust 백엔드, TS 프론트엔드)를 명확히 분리하여, 유지보수성과 확장성을 극대화합니다.

#### A. 백엔드 (Rust / `src-tauri/src`)

현재 여러 기능들이 `main.rs`나 상위 모듈에 혼재되어 있습니다. 이를 **도메인(기능)** 중심으로 분리합니다.

- **제안 구조**:
  ```
  src-tauri/src/
  ├── core/             # 애플리케이션의 핵심 로직, 다른 모듈에 의해 사용됨
  │   ├── mod.rs
  │   └── error.rs      # 전역 에러 타입
  ├── config/           # 설정 관리
  │   └── mod.rs
  ├── crawling/         # 크롤링 엔진 관련 모든 로직
  │   ├── mod.rs
  │   ├── collector.rs  # 데이터 수집
  │   ├── parser.rs     # HTML 파싱
  │   └── engine.rs     # 크롤링 실행 엔진
  ├── db/               # 데이터베이스 상호작용 (Repository 패턴)
  │   ├── mod.rs
  │   └── repository.rs
  ├── state/            # 공유 상태 관리
  │   └── mod.rs
  ├── api/              # Tauri 명령(command) 핸들러
  │   └── mod.rs
  └── main.rs           # 애플리케이션 진입점 (최소한의 설정 코드만 남김)
  ```
- **기대 효과**:
    - **명확한 책임 분리**: `crawling` 모듈은 크롤링만, `db` 모듈은 DB 연동만 책임집니다.
    - **테스트 용이성**: 각 모듈을 독립적으로 테스트하기 쉬워집니다.
    - **탐색 용이성**: 크롤링 관련 코드를 찾기 위해 더 이상 여러 파일을 헤맬 필요가 없습니다.

#### B. 프론트엔드 (TypeScript / `src`)

현재 `components`, `services` 등으로 기능별 분리가 되어 있으나, 이를 **피처(Feature)** 중심으로 한 단계 더 구조화합니다.

- **제안 구조**:
  ```
  src/
  ├── assets/
  ├── components/         # 공통 UI 컴포넌트 (Button, Input, Modal 등)
  │   └── ui/
  ├── features/           # 도메인/기능별 컴포넌트 및 로직
  │   ├── crawling_dashboard/
  │   │   ├── components/ # 대시보드에서만 사용하는 컴포넌트
  │   │   ├── hooks/      # 관련 React Hooks
  │   │   └── CrawlingDashboard.tsx
  │   └── system_status/
  │       └── SystemStatusView.tsx
  ├── services/           # API 호출, 외부 서비스 연동 (crawlingService.ts 등)
  ├── stores/             # 전역 상태 관리 (Zustand, Redux 등)
  ├── types/              # 전역 타입 정의
  ├── utils/              # 순수 유틸리티 함수
  └── App.tsx
  ```
- **기대 효과**:
    - **높은 응집도**: 특정 기능(feature)과 관련된 파일들이 한곳에 모여있어 관리가 편합니다.
    - **재사용성과 독립성**: 공통 컴포넌트와 피처별 컴포넌트가 명확히 분리됩니다.

## 3. 단계적 실행 방안

전면적인 리팩토링은 신중하게 접근해야 합니다. 아래와 같이 단계를 나누어 진행할 것을 제안합니다.

- **1단계 (즉시 실행): 문서 정리 및 아카이빙 (소요시간: 짧음, 위험도: 낮음)**
  - `docs/archive` 폴더를 만들고, 혼란을 주는 이전 문서들을 모두 이동시킵니다.
  - 이것만으로도 "어떤 문서를 봐야 하는가"에 대한 혼란이 즉시 해결됩니다.
- **2단계: 백엔드 코드 구조화 (소요시간: 중간, 위험도: 중간)**
  - 제안된 Rust 코드 구조에 따라 디렉토리를 생성하고 파일을 이동시킵니다.
  - `cargo check`, `cargo test`를 통해 구조 변경 후에도 코드가 정상 동작하는지 지속적으로 확인합니다.
- **3단계: 프론트엔드 코드 구조화 (소요시간: 중간, 위험도: 낮음)**
  - 제안된 TypeScript 코드 구조에 따라 파일을 정리합니다.

## 4. 결론

지금의 구조 개선 투자는 단기적으로는 약간의 시간을 소요하지만, 장기적으로는 **버그 감소, 개발 속도 향상, 팀원들의 스트레스 감소**라는 큰 이득으로 돌아올 것입니다.

먼저 **1단계: 문서 정리**부터 진행하는 것에 동의하시는지요?
