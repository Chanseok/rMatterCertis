# Matter Certis v2 - Development Roadmap

## 현재 상태 (2025년 6월 30일)

### ✅ 완성된 기능 (Phase 1 로깅 시스템 완료!)
- **로깅 시스템**: 설정 파일 기반, 실행 파일 위치 logs 폴더, JSON/콘솔 출력 지원
- 통합 데이터베이스 스키마 및 CRUD 작업
- 기본 UI 컴포넌트 (대시보드, 폼, 결과 페이지)  
- 크롤링 세션 관리 (시작/중지/상태 조회)
- HTTP 클라이언트 및 HTML 파싱 기능
- SolidJS 기반 상태 관리

### 🚧 부분 구현된 기능
- 크롤링 엔진 (테스트 바이너리에서만 동작)
- UI 스타일링 (기본 구조만 완성)
- 설정 관리 시스템 (config.rs 구조 완성, UI 연동 필요)

### ❌ 미구현 기능
- 백그라운드 크롤링 워커
- 실시간 진행률 업데이트
- 고급 크롤링 기능 (배치 처리, 재시도, 복구)
- 데이터 분석 및 시각화
- 사용자 지원 시스템

## 개발 원칙 및 접근 방법

### 💡 이전 프로젝트 경험 활용
본 프로젝트는 **이전에 동작하는 수준까지 구현했던 경험**을 바탕으로 진행합니다:
- 기존 노하우를 참고하여 **검증된 패턴과 아키텍처** 우선 적용
- 새로운 기술 실험보다는 **안정성과 완성도**에 중점  
- 이전 구현에서 발견된 **성능 병목점과 문제점들을 사전 해결**
- 단계별 증분 개발로 **기능별 검증 후 다음 단계 진행**

### 🎯 개발 우선순위 원칙
1. **핵심 기능 우선**: 크롤링 → 데이터 처리 → UI/UX 순서
2. **안정성 중심**: 로깅, 에러 처리, 복구 메커니즘을 각 단계마다 구현
3. **점진적 개선**: MVP → 기본 기능 → 고급 기능 → 완성도 순서
4. **사용자 관점**: 실제 운영 시나리오를 고려한 기능 우선순위

## 우선순위별 구현 계획

### Phase 2: 백그라운드 크롤링 워커 구현 (현재 최우선)
**목표**: 실제 크롤링 기능을 백그라운드에서 안정적으로 수행

#### 2.1 워커 아키텍처 설계 ⭐ **이전 경험 활용**
- [ ] `tokio::spawn`을 사용한 백그라운드 태스크
- [ ] 세션 기반 워커 생명주기 관리
- [ ] 워커 간 통신 채널 (mpsc 또는 broadcast)
- [ ] **이전 프로젝트의 워커 패턴 참고하여 검증된 구조 적용**

#### 2.2 크롤링 워크플로우 구현
- [ ] SessionManager 상태 업데이트 연동
- [ ] 진행률 실시간 계산 및 업데이트
- [ ] **기본 에러 처리 및 재시도 로직** (1차 구현)
- [ ] 중단/재개 기능

#### 2.3 성능 최적화 (이전 경험 기반)
- [ ] 동시 요청 수 제한 (**이전 프로젝트에서 최적값 참고**)
- [ ] 요청 간 지연 시간 설정
- [ ] 메모리 사용량 모니터링

**완료 조건**: UI에서 크롤링을 시작하면 백그라운드에서 실제 작업이 수행되고 진행률이 실시간으로 업데이트됨

### Phase 3: 고급 크롤링 및 시스템 안정성 ⭐ **prompts 반영**
**목표**: 실제 운영 환경에서 안정적으로 동작하는 고급 크롤링 시스템

#### 3.1 배치 처리 및 스케줄링 정책
- [ ] 대규모 URL을 청크 단위로 분할 처리
- [ ] 주기적 크롤링 스케줄러 구현
- [ ] 시간대별 크롤링 제한 (서버 부하 고려)
- [ ] **이전 프로젝트의 배치 크기 최적값 적용**

#### 3.2 재시도 및 실패 처리 메커니즘 ⭐ **핵심 기능**
- [ ] 네트워크 오류 재시도 로직 (지수 백오프)
- [ ] 웹사이트 구조 변경 감지 및 대응
- [ ] 영구 실패 판단 기준 정의
- [ ] **이전 경험 기반 재시도 전략 적용**

#### 3.3 실패 항목 복구 전략 (Dead-letter-queue)
- [ ] 실패한 항목들을 별도 테이블/큐에 저장
- [ ] 실패 원인 분류 및 태깅
- [ ] 수동/자동 재처리 인터페이스
- [ ] 실패 패턴 분석 및 리포팅

#### 3.4 성능 및 리소스 관리
- [ ] CPU/메모리 사용량 모니터링
- [ ] 동적 동시성 조절 (시스템 상태 기반)
- [ ] 크롤링 품질 메트릭 수집

**완료 조건**: 대규모 크롤링에서도 안정적이고, 실패한 항목들을 체계적으로 관리할 수 있어야 함

### Phase 4: UI-백엔드 실시간 연동
**목표**: 사용자 경험 개선을 위한 실시간 상태 동기화

#### 4.1 실시간 상태 업데이트
- [ ] Tauri의 이벤트 시스템 활용
- [ ] 크롤링 진행률 실시간 표시
- [ ] 에러 및 경고 알림 시스템
- [ ] 워커 상태별 상세 정보 표시

#### 4.2 상태 지속성
- [ ] 앱 재시작 시 크롤링 상태 복구
- [ ] 세션 히스토리 관리
- [ ] 중단된 작업 자동 복구 옵션

**완료 조건**: 사용자가 크롤링 상태를 실시간으로 모니터링할 수 있고, 앱을 재시작해도 작업이 지속됨

### Phase 5: 데이터 활용 및 분석 전략 ⭐ **prompts 핵심 요구사항**
**목표**: 수집된 데이터를 실제 비즈니스 가치로 전환

#### 5.1 데이터 분석 및 시각화 요구사항
- [ ] 업체별 상품 가격 변동 추이 분석
- [ ] 특정 키워드 상품 등록 빈도 분석  
- [ ] 카테고리별 상품 분포 및 트렌드
- [ ] **이전 프로젝트에서 유용했던 분석 지표 우선 구현**

#### 5.2 대시보드 및 리포팅 설계
- [ ] 실시간 크롤링 통계 대시보드
- [ ] 수집 데이터 품질 모니터링
- [ ] 주기적 자동 리포트 생성
- [ ] 사용자 정의 필터 및 검색

#### 5.3 데이터 Export/외부 연동
- [ ] CSV, Excel, JSON 형식 내보내기
- [ ] API 엔드포인트 제공 (선택사항)
- [ ] 외부 BI 툴 연동 가이드

**완료 조건**: 사용자가 수집된 데이터로부터 의미 있는 인사이트를 얻을 수 있어야 함

### Phase 6: 설정 및 환경 관리 강화 ⭐ **prompts 반영**
**목표**: 다양한 환경과 요구사항에 유연하게 대응

#### 6.1 중앙화된 설정 관리
- [ ] UI에서 모든 주요 설정 변경 가능
- [ ] 설정 변경 즉시 반영 (재시작 불필요)
- [ ] 설정 백업 및 복원 기능
- [ ] **이전 프로젝트에서 자주 변경된 설정들 우선 UI 노출**

#### 6.2 환경 분리 및 프로파일 관리
- [ ] Development/Production 환경 설정 분리
- [ ] 크롤링 프로파일 관리 (사이트별 설정)
- [ ] A/B 테스트를 위한 설정 버전 관리

#### 6.3 민감 정보 관리
- [ ] API 키, 비밀번호 암호화 저장
- [ ] 환경 변수 및 설정 파일 보안
- [ ] 사용자별 접근 권한 관리 (선택사항)

**완료 조건**: 개발자가 아닌 사용자도 시스템을 쉽게 설정하고 관리할 수 있어야 함

### Phase 7: UI 완성 및 안정화
**목표**: 프로덕션 레벨의 사용자 인터페이스 완성

#### 7.1 기능 완성
- [ ] 설정 페이지 완전 구현
- [ ] 고급 검색 및 필터링 기능
- [ ] 크롤링 스케줄링 UI
- [ ] 시스템 상태 모니터링 페이지

#### 7.2 UX 개선
- [ ] 반응형 디자인 완성
- [ ] 접근성 (a11y) 개선
- [ ] **이전 프로젝트에서 사용자 피드백이 좋았던 UI 패턴 적용**
- [ ] 키보드 단축키 지원

#### 7.3 안정성 강화
- [ ] 에러 경계 (Error Boundary) 구현
- [ ] 오프라인 모드 지원
- [ ] 성능 최적화 (가상화, lazy loading)

**완료 조건**: 일반 사용자가 별도 도움 없이 모든 기능을 직관적으로 사용할 수 있어야 함

### Phase 8: 사용자 지원 및 커뮤니티 ⭐ **prompts 신규 요구사항**
**목표**: 지속 가능한 소프트웨어 운영 기반 구축

#### 8.1 소통 채널 및 피드백 시스템
- [ ] 인앱 피드백 폼 구현
- [ ] GitHub Issues 템플릿 작성
- [ ] 공식 소통 채널 정의 (이메일, Discord 등)
- [ ] 피드백 처리 프로세스 문서화

#### 8.2 소프트웨어 업데이트 시스템
- [ ] Tauri 자동 업데이트 구현
- [ ] 버전 관리 정책 (SemVer) 적용
- [ ] 릴리즈 노트 자동 생성
- [ ] 롤백 메커니즘 구현

#### 8.3 사용자 지원 자료
- [ ] FAQ 및 사용자 매뉴얼 작성
- [ ] 문제 해결 가이드 (Troubleshooting)
- [ ] 튜토리얼 비디오 제작 (선택사항)

**완료 조건**: 사용자가 문제 발생 시 적절한 지원을 받을 수 있고, 소프트웨어가 지속적으로 개선되어야 함
- [ ] 워커 간 통신 채널 (mpsc 또는 broadcast)

#### 2.2 크롤링 워크플로우 구현
- [ ] SessionManager 상태 업데이트 연동
- [ ] 진행률 실시간 계산 및 업데이트
- [ ] 에러 처리 및 재시도 로직
- [ ] 중단/재개 기능

#### 2.3 성능 최적화
- [ ] 동시 요청 수 제한
- [ ] 요청 간 지연 시간 설정
- [ ] 메모리 사용량 모니터링

**완료 조건**: UI에서 크롤링을 시작하면 백그라운드에서 실제 작업이 수행되고 진행률이 실시간으로 업데이트됨

### Phase 3: UI-백엔드 실시간 연동
**목표**: 사용자 경험 개선을 위한 실시간 상태 동기화

#### 3.1 실시간 상태 업데이트
- [ ] Tauri의 이벤트 시스템 활용
- [ ] 크롤링 진행률 실시간 표시
- [ ] 에러 및 경고 알림 시스템

#### 3.2 상태 지속성
- [ ] 앱 재시작 시 크롤링 상태 복구
- [ ] 세션 히스토리 관리
- [ ] 중단된 작업 자동 복구 옵션

**완료 조건**: 사용자가 크롤링 상태를 실시간으로 모니터링할 수 있고, 앱을 재시작해도 작업이 지속됨

### Phase 4: UI 완성 및 안정화
**목표**: 프로덕션 레벨의 사용자 인터페이스 완성

#### 4.1 기능 완성
- [ ] 설정 페이지 완전 구현
- [ ] 고급 검색 및 필터링 기능
- [ ] 데이터 내보내기 (CSV, JSON)
- [ ] 크롤링 스케줄링 기능

#### 4.2 UX 개선
- [ ] 반응형 디자인 완성
- [ ] 접근성 (a11y) 개선
- [ ] 다국어 지원 기반 마련
- [ ] 키보드 단축키 지원

#### 4.3 안정성 강화
- [ ] 에러 경계 (Error Boundary) 구현
- [ ] 오프라인 모드 지원
- [ ] 성능 최적화 (가상화, lazy loading)

**완료 조건**: 일반 사용자가 별도 도움 없이 모든 기능을 직관적으로 사용할 수 있어야 함

## 마일스톤 및 예상 일정

### ✅ M1: 로깅 시스템 완성 (완료 - 2025.06.30)
- 설정 파일 기반 로깅 시스템 구현
- 실행 파일 위치 logs 폴더 생성
- JSON/콘솔 출력 지원 및 환경별 설정

### 🎯 M2: 크롤링 워커 MVP (예상: 3-5일)
- 백그라운드에서 실제 크롤링 수행
- 기본적인 진행률 표시
- 시작/중지 기능 동작
- **이전 프로젝트 패턴 적용으로 개발 속도 향상 예상**

### 🎯 M3: 고급 크롤링 시스템 (예상: 5-7일)
- 배치 처리 및 재시도 로직 완성
- 실패 항목 복구 메커니즘
- 성능 최적화 및 리소스 관리
- **이전 경험 기반 최적값 적용으로 시행착오 최소화**

### 🎯 M4: 실시간 연동 완성 (예상: 2-3일)
- UI에서 크롤링 상태 실시간 확인
- 에러 알림 시스템 동작
- 세션 복구 기능

### 🎯 M5: 데이터 활용 시스템 (예상: 4-6일)
- 데이터 분석 및 시각화 기능
- 대시보드 및 리포팅
- 데이터 내보내기 기능
- **이전 프로젝트에서 검증된 분석 지표 우선 구현**

### 🎯 M6: 설정 관리 강화 (예상: 3-4일)
- 중앙화된 설정 UI
- 환경별 설정 분리
- 민감 정보 보안 관리

### 🎯 M7: 프로덕션 준비 완료 (예상: 5-7일)
- 모든 UI 기능 완성
- 성능 최적화 완료
- 사용자 테스트 완료

### 🎯 M8: 운영 및 지원 시스템 (예상: 3-5일)
- 자동 업데이트 시스템
- 피드백 및 지원 채널
- 사용자 문서 및 FAQ

**총 예상 개발 기간**: 25-40일 (이전 프로젝트 경험으로 효율성 향상)

## 기술적 고려사항 및 개발 전략

### 이전 프로젝트 경험 활용 전략
- **검증된 패턴 우선 적용**: 새로운 실험보다는 이전에 동작이 확인된 아키텍처와 구현 방식 우선 채택
- **성능 최적값 재사용**: 동시 요청 수, 배치 크기, 재시도 횟수 등 이전 프로젝트에서 튜닝된 값들 활용
- **문제점 사전 해결**: 이전 구현에서 발견된 메모리 누수, 성능 병목점 등을 사전에 고려하여 설계
- **점진적 개선**: 기본 동작 확보 후 새로운 기능이나 최적화를 단계적으로 추가

### 의존성 관리
- **검증된 크레이트 우선**: 이전 프로젝트에서 안정성이 확인된 라이브러리 우선 사용
- 새로운 크레이트 추가 시 신중한 검토 (기능 향상 vs 복잡도 증가)
- 빌드 시간 및 바이너리 크기 모니터링
- **이전 경험으로 검증된 버전 조합 활용**

### 성능 모니터링
- **이전 프로젝트의 성능 기준점 활용**: 메모리 사용량, 크롤링 속도 등의 벤치마크 참고
- 메모리 사용량 추적 및 누수 방지
- 크롤링 속도 벤치마크 지속적 측정
- 데이터베이스 쿼리 최적화 (이전 경험의 slow query 패턴 회피)

### 안정성 및 복구 전략
- **이전 프로젝트의 장애 시나리오 기반 설계**: 네트워크 단절, 메모리 부족, 파일 시스템 오류 등
- 크래시 발생 시 자동 복구 메커니즘
- 데이터 무결성 보장을 위한 트랜잭션 관리
- 백업 및 복구 프로세스 자동화

### 코드 품질 및 유지보수성
- **이전 프로젝트에서 유지보수가 어려웠던 부분 개선**: 복잡한 상태 관리, 하드코딩된 설정 등
- 단위 테스트 coverage 유지 (최소 70% 목표)
- 문서화 지속적 업데이트 (코드 변경 시 문서 동기화)
- 코드 리뷰 및 리팩토링 정기 실시

### 운영 환경 대비
- **이전 경험의 운영 이슈 사전 대응**: 로그 파일 적재, 설정 변경의 어려움, 모니터링 부족 등
- 프로덕션 환경에서의 모니터링 및 알림 시스템 구축
- 무중단 업데이트 메커니즘 설계
- 사용자 데이터 마이그레이션 전략 수립

### 확장성 고려사항
- **이전 프로젝트의 확장 한계점 분석**: 데이터베이스 성능, 메모리 사용량, 동시 처리량 등
- 수평적 확장 가능성 (멀티 인스턴스 실행)
- 데이터베이스 파티셔닝 전략
- 마이크로서비스 분리 가능성 검토 (필요시)

---
*이 로드맵은 실제 진행 상황과 이전 프로젝트 경험을 바탕으로 지속적으로 조정됩니다.*
*특히 이전 구현에서 검증된 패턴과 최적값들을 최대한 활용하여 개발 효율성을 높입니다.*
