/**
 * settingsStore - ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì • ê´€ë¦¬ ìŠ¤í† ì–´
 * ë°±ì—”ë“œì™€ ì—°ë™í•˜ì—¬ ì„¤ì •ì„ ì €ì¥/ë¡œë“œ
 */

import { createStore } from 'solid-js/store';
import { invoke } from '@tauri-apps/api/core';

// ì„¤ì • íƒ€ì… ì •ì˜
export interface CrawlingSettings {
  concurrent_downloads: number;
  request_delay_ms: number;
  timeout_seconds: number;
  retry_count: number;
}

export interface LoggingSettings {
  level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';
  terminal_output: boolean;
  file_logging: boolean;
  max_file_size_mb: number;
  max_files: number;
  auto_cleanup_logs: boolean;
}

export interface BatchSettings {
  batch_size: number;
  progress_interval_ms: number;
  auto_backup: boolean;
  batch_delay_ms: number;
  enable_batch_processing: boolean;
}

export interface AppSettings {
  crawling: CrawlingSettings;
  logging: LoggingSettings;
  batch: BatchSettings;
}

interface SettingsStore {
  settings: AppSettings;
  isLoading: boolean;
  isDirty: boolean;
  lastSaved: string | null;
  expandedSections: {
    basic: boolean;
    logging: boolean;
    batch: boolean;
    advanced: boolean;
  };
  
  // ë©”ì„œë“œë“¤
  loadSettings: () => Promise<void>;
  saveSettings: () => Promise<void>;
  resetToDefaults: () => Promise<void>;
  updateCrawlingSettings: (settings: Partial<CrawlingSettings>) => void;
  updateLoggingSettings: (settings: Partial<LoggingSettings>) => void;
  updateBatchSettings: (settings: Partial<BatchSettings>) => void;
  toggleSection: (section: keyof SettingsStore['expandedSections']) => void;
  markDirty: () => void;
}

// ê¸°ë³¸ ì„¤ì •ê°’
const DEFAULT_SETTINGS: AppSettings = {
  crawling: {
    concurrent_downloads: 3,
    request_delay_ms: 1000,
    timeout_seconds: 30,
    retry_count: 3
  },
  logging: {
    level: 'INFO',
    terminal_output: true,
    file_logging: true,
    max_file_size_mb: 10,
    max_files: 5,
    auto_cleanup_logs: true
  },
  batch: {
    batch_size: 50,
    progress_interval_ms: 1000,
    auto_backup: true,
    batch_delay_ms: 100,
    enable_batch_processing: true
  }
};

const [settingsState, setSettingsState] = createStore<SettingsStore>({
  settings: { ...DEFAULT_SETTINGS },
  isLoading: false,
  isDirty: false,
  lastSaved: null,
  expandedSections: {
    basic: true,
    logging: true,
    batch: true,
    advanced: false
  },

  // ì„¤ì • ë¡œë“œ
  async loadSettings() {
    setSettingsState('isLoading', true);
    try {
      console.log('ğŸ”§ Loading settings from backend...');
      const loadedSettings = await invoke<AppSettings>('get_app_settings');
      
      if (loadedSettings) {
        setSettingsState('settings', { ...DEFAULT_SETTINGS, ...loadedSettings });
        console.log('âœ… Settings loaded:', loadedSettings);
      }
    } catch (error) {
      console.error('âŒ Failed to load settings:', error);
      
      // Fallback to localStorage
      try {
        const localSettings = localStorage.getItem('appSettings');
        if (localSettings) {
          const parsed = JSON.parse(localSettings) as AppSettings;
          setSettingsState('settings', { ...DEFAULT_SETTINGS, ...parsed });
          console.log('âœ… Settings loaded from localStorage');
        }
      } catch (localError) {
        console.error('âŒ Failed to load from localStorage:', localError);
      }
    } finally {
      setSettingsState('isLoading', false);
      setSettingsState('isDirty', false);
    }
  },

  // ì„¤ì • ì €ì¥
  async saveSettings() {
    if (!settingsState.isDirty) {
      console.log('â„¹ï¸ No changes to save');
      return;
    }

    setSettingsState('isLoading', true);
    try {
      console.log('ğŸ”§ Saving settings to backend...');
      await invoke('save_app_settings', { settings: settingsState.settings });
      
      setSettingsState('lastSaved', new Date().toISOString());
      setSettingsState('isDirty', false);
      console.log('âœ… Settings saved successfully');
      
      // Also save to localStorage as backup
      localStorage.setItem('appSettings', JSON.stringify(settingsState.settings));
    } catch (error) {
      console.error('âŒ Failed to save settings:', error);
      
      // Fallback to localStorage
      try {
        localStorage.setItem('appSettings', JSON.stringify(settingsState.settings));
        setSettingsState('lastSaved', new Date().toISOString());
        setSettingsState('isDirty', false);
        console.log('âœ… Settings saved to localStorage');
      } catch (localError) {
        console.error('âŒ Failed to save to localStorage:', localError);
        throw localError;
      }
    } finally {
      setSettingsState('isLoading', false);
    }
  },

  // ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  async resetToDefaults() {
    setSettingsState('settings', { ...DEFAULT_SETTINGS });
    settingsState.markDirty();
    await settingsState.saveSettings();
    console.log('âœ… Settings reset to defaults');
  },

  // í¬ë¡¤ë§ ì„¤ì • ì—…ë°ì´íŠ¸
  updateCrawlingSettings(newSettings: Partial<CrawlingSettings>) {
    setSettingsState('settings', 'crawling', (prev) => ({ ...prev, ...newSettings }));
    settingsState.markDirty();
  },

  // ë¡œê¹… ì„¤ì • ì—…ë°ì´íŠ¸
  updateLoggingSettings(newSettings: Partial<LoggingSettings>) {
    setSettingsState('settings', 'logging', (prev) => ({ ...prev, ...newSettings }));
    settingsState.markDirty();
  },

  // ë°°ì¹˜ ì„¤ì • ì—…ë°ì´íŠ¸
  updateBatchSettings(newSettings: Partial<BatchSettings>) {
    setSettingsState('settings', 'batch', (prev) => ({ ...prev, ...newSettings }));
    settingsState.markDirty();
  },

  // ì„¹ì…˜ í† ê¸€
  toggleSection(section: keyof SettingsStore['expandedSections']) {
    setSettingsState('expandedSections', section, (prev) => !prev);
    // ì„¹ì…˜ ìƒíƒœë„ localStorageì— ì €ì¥
    localStorage.setItem('settingsExpandedSections', JSON.stringify(settingsState.expandedSections));
  },

  // ë³€ê²½ì‚¬í•­ í‘œì‹œ
  markDirty() {
    setSettingsState('isDirty', true);
  }
});

// ì´ˆê¸°í™” ì‹œ ì„¹ì…˜ ìƒíƒœ ë³µì›
try {
  const savedSections = localStorage.getItem('settingsExpandedSections');
  if (savedSections) {
    const parsed = JSON.parse(savedSections);
    setSettingsState('expandedSections', parsed);
  }
} catch (error) {
  console.warn('Failed to restore section states:', error);
}

export { settingsState };
